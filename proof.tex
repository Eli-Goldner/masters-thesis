% 
% File acl2019.tex
%
%% Based on the style files for ACL 2018, NAACL 2018/19, which were
%% Based on the style files for ACL-2015, with some improvements
%%  taken from the NAACL-2016 style
%% Based on the style files for ACL-2014, which were, in turn,
%% based on ACL-2013, ACL-2012, ACL-2011, ACL-2010, ACL-IJCNLP-2009,
%% EACL-2009, IJCNLP-2008...
%% Based on the style files for EACL 2006 by 
%%e.agirre@ehu.es or Sergi.Balari@uab.es
%% and that of ACL 08 by Joakim Nivre and Noah Smith

\documentclass[11pt]{article}
%%\usepackage[hyperref]{acl2021}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{times}
\usepackage{latexsym}
\usepackage{lingstyle}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{bussproofs}
\usepackage{multicol}
%%\usepackage{prftree.sty} 
\usepackage{natbib}
\usepackage{cite}
\usepackage{float}
%%\usepackage{stfloats}
%%\usepackage{turnstile}
\usepackage{rotating}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{framed}
\usepackage[ruled,vlined]{algorithm2e}

\usepackage[margin=0.5in]{geometry}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{corollary}{Corollary}


\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\DeclareMathSymbol{:}{\mathord}{operators}{"3A}
\renewcommand{\phi}{\varphi}
%%\newenvironment{proof}{\paragraph{Proof:}}{\hfill$\square$}

\usetikzlibrary{arrows,positioning,shapes} 
\tikzset{
    %Define standard arrow tip
    >=stealth',
    %Define style for boxes
    amrnode/.style={
             ellipse,
             draw=black, very thick,
             font=\small},
    scopenode/.style={
             ellipse,
             draw=red, very thick, dashed,
             text=red,
             font=\small},
    % Define arrow style
    amrarrow/.style={
            ->,
            thick,
            font=\small},
    scopearrow/.style={
              ->,
              red,
              thick,
              dashed,
              font=\small}
}

 \def\drs#1#2{\begin{tabular}{|l|}\hline #1 \\ \hline \\
                [-8pt] #2\\[-8pt] \\ \hline \end{tabular} }

 \def\ddrs#1{\begin{tabular}{||c||}\hline \\
                [-8pt] #1\\[-8pt] \\ \hline \end{tabular} }

 \def\topdrs#1#2{\begin{tabular}{|l|}\hline #1 \\ \hline \\
                [-8pt] #2 \\[-8pt] \\ \hline \end{tabular} }

 %%\def\proof#1#2#3#4{\drs{#1}{#2} \ $\vdash$ \ \drs{#3}{#4}}
 \def\modimp#1#2#3#4{\mbox{\drs{#1}{#2} \ $\Box$ \ \drs{#3}{#4}}}
 \def\imp#1#2#3#4{\drs{#1}{#2} \ $\Rightarrow$ \ \drs{#3}{#4}}
 \def\dis#1#2#3#4{\mbox{\drs{#1}{#2} \ $\vee$ \ \drs{#3}{#4}}}
 \def\int#1#2{\mbox{$^{\wedge}$ \ \drs{#1}{#2}}}
 %%\def\pos#1#2{\mbox{$\lozenge$ \ \drs{#1}{#2}}}
 %%\def\nec#1#2{\mbox{$\Box$ \ \drs{#1}{#2}}}
 \def\nega#1#2{\mbox{$\neg$ \ \drs{#1}{#2}}}
 \def\pred#1#2#3{\mbox{#1\ :\drs{#2}{#3}}}


\usepackage{url} 

\usepackage[acronym]{glossaries} % 'nomain' to disable automatic generation of "glossary" section 
\glsdisablehyper % disable hyperlink to non-existing glossary section 
%\aclfinalcopy % Uncomment this line for the final submission
%\def\aclpaperid{***} %  Enter the acl Paper ID here

%\setlength\titlebox{5cm}
% You can expand the titlebox if you need extra space
% to show all the authors. Please do not make the titlebox
% smaller than 5cm (the original size); we will check this
% in the camera-ready version and ask you to change it back.

\newcommand\BibTeX{B\textsc{ib}\TeX}

\title{Formalization of AMR Inference via Hybrid Logic Tableaux}
 

 
\author{
  Eli Goldner
}
\begin{document}
\maketitle
\begin{abstract}
  AMR and its extensions have become popular in semantic representation due
  to their ease of annotation by non-experts, attention to the predicative core of sentences,
  and abstraction away from various syntactic matter.
  An area where AMR and its extensions warrant improvement is formalization
  and suitability for inference, where it is lacking compared to
  other semantic representations, such as
  description logics, episodic logic, and discourse representation theory.
  This thesis presents a formalization of inference over a merging of
  \citeauthor{donatelli-etal-2018-annotation}'s \citeyearpar{donatelli-etal-2018-annotation} AMR extension for tense and aspect
  and with \citeauthor{pustejovsky-etal-2019-modeling}'s \citeyearpar{pustejovsky-etal-2019-modeling} AMR extension for quantification and scope.
  Inference is modeled with a merging of \citeauthor{hansen2007tableau}'s
  \citeyearpar{hansen2007tableau} tableau method for
  first-order hybrid logic with varying domain semantics 
  ({\it FHL}) and \citeauthor{blackburn2012indexical}'s \citeyearpar{blackburn2012indexical}
  tableau method for basic hybrid tense logic ({\it BHTL}).
  We motivate the merging of these AMR variants,
  present their interpretation and inference in the combination of {\it FHL}
  and {\it BHTL}, which we will call {\it FHTL} (first-order hybrid tense logic),
  and demonstrate {\it FHTL}'s soundness, completeness,
  and decidability. 


  
\end{abstract}

\section{Merging Quantified Hybrid Logic and Indexical Hybrid Tense Logic}

\subsection{Background}

\subsection{First-order Hybrid Logic}
\citet*{hansen2007tableau}

from 

\citet*{quantified}

\subsection{Basic Hybrid Tense Logic}

\citet*{blackburn2012indexical}

\section{First-order Hybrid Tense Logic - Syntax and Semantics}
\smallskip
The syntax of {\it FHTL} is identical to {\it FHL} as given in \citet*{hansen2007tableau} except
uses of $\downarrow$ as in $\downarrow w . \phi$ are omitted along
with $\Box$ and $\lozenge$ as in $\Box \phi$ and $\lozenge \phi$.
$\Box$ and $\lozenge$ are replaced by their semantic equivalents
$F$ and $G$ and their temporal duals $P$ and $H$ are added.

\smallskip


Atomic formulae are the same as in {\it FHL}, symbols in \textsf{NOM}
and \textsf{SVAR} together with first-order atomic formulae
generated from the predicate symbols and equality over the terms. 
Thus complex formulae are generated from the atomic formulae according to the
following rules:
$$\neg \phi \mid \phi \land \psi \mid \phi \lor \psi \mid \phi \to \psi \mid \exists x \phi \mid \forall x \phi \mid F \phi \mid G \phi \mid P \phi \mid H \phi \mid @_n \phi $$



Since we want the domain of quantification to be indexed
over the collection of nominals/times, we look to
\citeauthor{fitting-modal}'s \citeyearpar{fitting-modal}
treatment of first-order modal logic with varying domain semantics
and use it to alter the {\it FHL} model definition
to the following:
$$(T, R, D_t, I_{nom}, I_t)_{t \in T}$$
Thus with varying domain semantics a {\it FHTL}
model is identical to the definition for a {\it FHL} model in that:
\begin{itemize}
  \item
    $(T,R)$ is a modal frame.
  \item
    $I_{nom}$ is a function assigning members of $T$ to nominals.
\end{itemize}

The differences manifest on the level of the model and
interpretation.  Namely, where $D = \cup_{t \in T} D_t$,
$(D, I_t)$ is a first-order model where:
\begin{itemize}
\item
  $I_t (q) \in D$ where $q$ is a unary function symbol.
\item
  $I_t (P) \in D^k$ where $P$ is a $k$-ary predicate symbol.
\end{itemize}

Notice we've relaxed the requirement that $I_t (c) = I_{t'} (c)$ for
$c$ a constant and $t,t' \in T$, since the interpretation of the
constant need not exist at both times.  This permits us to distinguish
between the domain of a frame and the domain of a time/world,
in a way that prevents a variable $x$ from failing to refer
at a given time/world, even if it has no interpretation at that time.
Intuitively this permits {\it FHTL} to handle interpretation of entities
in natural language utterances, which while reasonable to refer to
do not exist at a current time, e.g. previous and future presidents.


\smallskip

Free variables are handled similarly as in {\it FHL}.
Where again $D = \cup_{t \in T} D_t $, a {\it FHTL} assignment is a function:
$$g : \textsf{SVAR} \cup \textsf{FVAR} \to T \cup D $$
Where state variables are sent to times/worlds and
first-order variables are sent to $D$, the domain
of the frame.
Thus given a model and an assignment $g$,
the interpretation of terms $t$ denoted by $\overline{t}$
is defined as:
\begin{itemize}
\item
  $\overline{x} = g(x)$ for $x$ a variable.
\item
  $\overline{c} = I_t (c)$ for $c$ a constant and some $t \in T$.
\item For $q$ a unary function symbol:
  \begin{itemize} 
  \item
    For $n$ a nominal:
    $$\overline{@_n q} = I_{I_{nom}(n)} (q)$$
  \item
    For $n$ a state variable:
    $$\overline{@_n q} = I_{g(n)} (q)$$
  \end{itemize}
\end{itemize}

Finally we say an assignment $g'$ is an $x$-variant of $g$ if $g'$
and $g$ on all variables except possiblly $x$.
In particular, we say $g'$ is an $x$-variant of $g$ at $t$, a time, if $g'$
and $g$ on all variables except possiblly $x$ and $g'(x) \in D_t$.
We omit definitions for $\land$, $\to$, $H$, $G$, and $\forall$, since
they can be defined in terms of the other rules.
Given a model $\mathfrak{M}$, a variable assignment $g$,
and a state $s$, the inductive definition of
$\mathfrak{M}, s \vDash_g \phi$ is:

\begin{alignat*}{2}
  &\mathfrak{M}, s \vDash_g P(t_1, \dotsc , t_n )  && \Longleftrightarrow \langle \overline{t_1}, \dotsc , \overline{t_n} \rangle \in I_s (P)  \\
  &\mathfrak{M},  s \vDash_g t_i = t_j  && \Longleftrightarrow \overline{t_i} = \overline{t_j}  \\
  &\mathfrak{M},  s \vDash_g n && \Longleftrightarrow I_{nom} (n) = s, \text{for }n\text{ a nominal}  \\
  & \mathfrak{M},  s \vDash_g w && \Longleftrightarrow g(w) = s, \text{for }w\text{ a state variable}  \\
  & \mathfrak{M},  s \vDash_g \neg \phi && \Longleftrightarrow  \mathfrak{M},  s \not\vDash_g \phi \\
  & \mathfrak{M},  s \vDash_g \phi \lor \psi && \Longleftrightarrow  \mathfrak{M},  s \vDash_g \phi \text{ or } \mathfrak{M},  s \vDash_g \psi \\
  & \mathfrak{M},  s \vDash_g \exists x \phi && \Longleftrightarrow \mathfrak{M}, s \vDash_{g'} \phi \text{ for some } x\text{-variant }g'\text{ of } g \text{ at } s \\
  & \mathfrak{M},  s \vDash_g F \phi && \Longleftrightarrow \mathfrak{M},  t \vDash_g \phi \text{ for some } t \in T \text{ such that } Rst \\
  & \mathfrak{M},  s \vDash_g P \phi && \Longleftrightarrow \mathfrak{M},  t \vDash_g \phi \text{ for some } t \in T \text{ such that } Rts \\
  & \mathfrak{M},  s \vDash_g @_n \phi && \Longleftrightarrow \mathfrak{M},  I_{nom}(n) \vDash_g \phi \text{ for } n \text{ a nominal } \\
  & \mathfrak{M},  s \vDash_g @_w \phi && \Longleftrightarrow \mathfrak{M},  g(w) \vDash_g \phi \text{ for } w \text{ a state variable }
  %%\caption{$AT_x$}
\end{alignat*}

\subsection{The Tableau Calculus}



\begin{figure*}[!h]
  \begin{framed}
    \centering
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s @_t \phi$}
        \RightLabel{$[@]$}
        \UnaryInfC{$@_t \phi$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s \neg @_t \phi$}
        \RightLabel{$[\neg @]$}
        \UnaryInfC{$@_t \neg \phi$} 
      \end{prooftree}
      
      \end{multicols}
    
    
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s P t$}
        \RightLabel{$[P\textsf{--Trans}]$}
        \UnaryInfC{$@_t F s$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s F t$}
        \RightLabel{$[F\textsf{--Trans}]$}
        \UnaryInfC{$@_t P s$}  
      \end{prooftree}
    \end{multicols}
    
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s P t$}
        \AxiomC{$@_t u$}
        \RightLabel{$P\textsf{--Bridge}$}
        \BinaryInfC{$@_s P u$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s F t$}
        \AxiomC{$@_t u$}
        \RightLabel{$F\textsf{--Bridge}$}
        \BinaryInfC{$@_s F u$}  
      \end{prooftree}
    \end{multicols}
    
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s t$}
        \AxiomC{$@_s \phi$}
        \RightLabel{$[\textsf{Nom}]$}
        \BinaryInfC{$@_t \phi$} 
      \end{prooftree}

      \begin{prooftree}
        \AxiomC{$[i\text{ on the branch}]$}
        \RightLabel{$[\textsf{ref}]$}
        \UnaryInfC{$@_i i$} 
      \end{prooftree}
    
    \end{multicols}
    \caption{@ rules}
  \end{framed}
\end{figure*}


\iffalse

\begin{prooftree}
  \AxiomC{$@_t s$}
  \RightLabel{$[\textsf{Sym}]$}
  \UnaryInfC{$@_s t$}
\end{prooftree}

\fi


\par

For \textsf{Nom}  we have the constraint that
if the premise $@_t \phi$ are of the form $@_t X c$
where $X \in \{ F, P, \neg G, \neg H \}$ and $c$ is a nominal or state variable,
then $@_t \phi$ is a root subformula.
Similarly  for $\textsf{Nom}^{-1}$ and the premise $@_s\phi$.  
\par

\begin{figure*}[!h]
  \begin{framed}
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s F \phi$}
        \RightLabel{$[F]$}
        \UnaryInfC{$@_s F a$}
        \noLine
        \UnaryInfC{$@_a \phi$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s P \phi$}
        \RightLabel{$[P]$}
        \UnaryInfC{$@_s P a$}
        \noLine
        \UnaryInfC{$@_a \phi$}
      \end{prooftree}
      
    \end{multicols}
  \end{framed}
  \caption{$F$ and $P$ rules}
  \label{fnp}
\end{figure*}

In all rules in \cref{fnp}, the nominal $a$ is new to the branch.
We have the additional constraint that if $\phi$ in the premise
is a nominal or state variable, then the premise must be a root subformula
in order for the rule to be applicable.

Following \citet*{fitting-modal} we assume for each nominal
or state variable $s$,
there is an infinite list of parameters, where parameters are free variables
which are never quantified over, arranged in such a way that different
nominals/state variables
never share the same parameter.  Informally we write $p_s$ to indicate
a parameter is associated with a nominal/state variable $s$.  
\par
We also introduce the notion of a grounded term.  A grounded term
is either a first-order constant, a parameter,
or a grounded definite description, i.e.
a term of the form $@_n q$ for $n$ a nominal
and $q$ a unary function symbol.

\begin{figure*}[!h]
  \begin{framed}
  \begin{multicols}{2}
    \begin{prooftree}
      \AxiomC{$@_s \exists x \phi$}
      \RightLabel{$(\exists)$}
      \UnaryInfC{$@_s \phi[s:p / x]$} 
    \end{prooftree}
    
    \begin{prooftree}
        \AxiomC{$@_s \neg \exists x \phi$}
        \RightLabel{$(\neg \exists)$}
        \UnaryInfC{$@_s \neg \phi[t / x]$} 
      \end{prooftree}
  \end{multicols}
  \caption{Quantifier rules}
  \label{quant}
  \end{framed}
\end{figure*}

\par
In $(\exists)$, $s:p$ is a parameter associated with the
nominal $s$, with the requirement that it is new to the branch.
Since parameters are never quantified over,
$s:p$ is free in $\phi[s:p / x]$ but refers the same way as a constant.
In $(\neg \exists)$, $t$ is any parameter or term without variables which exists at $s$.
Following \citet*{fitting-tab} to ensure termination of tableau construction
we borrow the notion of quantifier depth
\begin{figure*}[!h]
%%\begin{figure*}[H]
  \begin{framed}
    \centering
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{}
        \RightLabel{\bf (ref)}
        \UnaryInfC{$@_i j:t = j:t$} 
      \end{prooftree}
      
      
      \begin{prooftree}
        \AxiomC{$@_i j:t = k:s$}
        \AxiomC{$@_i \phi$}
        \RightLabel{\bf (sub)}
        \BinaryInfC{$@_i \phi[j:t // k:s]$} 
      \end{prooftree}
    \end{multicols}

    \caption{Equality rules}
  \end{framed}
\end{figure*}


\begin{figure*}[!h]
  %% \begin{figure*}[H]
  \begin{framed}
  \begin{multicols}{3}
    \begin{prooftree}
      \AxiomC{$@_i k_1 : t = k_2 : s$}
      \RightLabel{\bf (:1)}
      \UnaryInfC{$@_i k_1 : t = k_2 : s$}
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$@_i j$}
      \RightLabel{\bf (:2)}
      \UnaryInfC{$@_k i: t = j : t$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{}
      \RightLabel{\bf (:3)}
      \UnaryInfC{$@_i k :j: t = j : t$}
    \end{prooftree}
  \end{multicols}

  \begin{multicols}{2}
    \begin{prooftree}
      \AxiomC{$@_i R(t_1,...,t_n)$}
      \RightLabel{\bf (:fix 1)}
      \UnaryInfC{$@_i R(i:t_1,...,i:t_n)$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$@_i \neg R(t_1,...,t_n)$}
      \RightLabel{\bf (:fix 2)}
      \UnaryInfC{$@_i \neg R(i:t_1,...,i:t_n)$}
    \end{prooftree}
  \end{multicols}
  
  \begin{multicols}{2}  
    \begin{prooftree}
      \AxiomC{$@_i t = s$}
      \RightLabel{\bf (:fix 3)}
      \UnaryInfC{$@_i i : t = i : s$}
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$@_i \neg t = s$}
      \RightLabel{\bf (:fix 4)}
      \UnaryInfC{$@_i \neg i : t = i : s$}
    \end{prooftree}
  \end{multicols}
  
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\bf (:func)}
    \UnaryInfC{$@_i f(t_1,..., t_n) = f(i:t_1,..., i:t_n)$}
  \end{prooftree}
  
  \caption{{\it FHTL} term rules}
\end{framed}
\end{figure*}

\begin{figure*}
  %% \begin{figure*}[hbt!]
  \begin{framed}
    \centering
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$\neg @_s \phi$}
        \RightLabel{$[\neg]$}
        \UnaryInfC{$@_s \neg \phi$}
      \end{prooftree}

      \begin{prooftree}
        \AxiomC{$@_s \neg \phi$}
        \RightLabel{$[\neg^{-1}]$}
        \UnaryInfC{$\neg @_s \phi$}
      \end{prooftree}
     \end{multicols}
    \caption{Negation rules}
  \end{framed}
\end{figure*}

\begin{figure*}
%%\begin{figure*}[hbt!]
  \begin{framed}
  \centering
  \begin{multicols}{3}
    \begin{prooftree}
      \AxiomC{$@_s (\phi \lor \psi)$}
      \RightLabel{$[\lor]$}
      \UnaryInfC{$@_s \phi \mid @_s \psi$} 
    \end{prooftree}
    
    
    \begin{prooftree}
      \AxiomC{$@_s \neg (\phi \lor \psi)$}
      \RightLabel{$[\neg \lor]$}
      \UnaryInfC{$@_s \neg \phi$}
      \noLine
      \UnaryInfC{$@_s \neg \psi$}
    \end{prooftree}

     
    \begin{prooftree}
      \AxiomC{$ @_s \neg \neg \phi$}
      \RightLabel{$[\neg \neg]$}
      \UnaryInfC{$@_s \phi$}
    \end{prooftree}
    
  \end{multicols}
  \caption{Propositional rules.}
\end{framed}
\end{figure*}


\begin{figure*}
  \begin{framed}
  \centering
  \begin{multicols}{2}
    \begin{prooftree}
      \AxiomC{$@_s \neg P \phi$}
      \AxiomC{$@_s P t$}
      \RightLabel{$[H]$}
      \BinaryInfC{$@_t \neg \phi$} 
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$@_s \neg F \phi$}
      \AxiomC{$@_s F t$}
      \RightLabel{$[G]$}
      \BinaryInfC{$@_t \neg \phi$}
    \end{prooftree}
  \end{multicols}
  \caption{$G$ and $H$ rules}
\end{framed}
\end{figure*}



\subsection{Soundness and completeness}

The proof of soundness and completeness of
{\it FHL} in \citet*{hansen2007tableau}
uses the notions of $\lozenge$--{\it completeness}
and $\exists$--{\it completeness}.  As a result we substitute
$\lozenge$--completeness with the equivalent notion 
$F$--{\it completeness} and add the notion of
$P$--{\it completeness} where the $\exists$--completeness
stays the same as before.  Thus set of $@$-formulae
(formulae in the extended language (including parameters) of the form $@_i \phi$)
is $F$--complete if:
$$@_i F \phi \in S \Longrightarrow @_i F j \text{ or } @_j P i, @_j \phi \in S, \text{ for some nominal } j$$
A set of $@$-formulae is $P$--complete if:
$$@_i P \phi \in S \Longrightarrow @_i P j \text{ or } @_j F i, @_j \phi \in S, \text{ for some nominal } j$$
Soundness and completeness for for {\it FHTL} follows straightforward modification of Hansen's proof of soundness and completeness
for {\it FHL} in a way that reflects the new formulae of the form $@_i P \phi$. 


\subsection{Tableau Construction}

\begin{definition}[{\bf Closed and open}]
  If a tableau branch contains a formula
  $@_s \phi$ and its negation $@_s \neg \phi$
  we say the branch is {\it closed}.
  If every branch of the tableau is closed we
  say the tableau itself is closed.  If a
  tableau or branch is not closed we say it is {\it open}.
\end{definition}

A closed tableau is a proof of the unsatisfiability of the tableau's root formula, i.e.
there is no model or assignment of variables in which it holds.  The question of when a tableau
indicates satisfiability of the root formula leads us to our next definition.

\begin{definition}[{\bf Saturation}]
  A tableau branch is {\it saturated}
  if no more rules can be applied to the branch in a way that
  satisfies their constraints.
  If every branch of the tableau
  is saturated we say the tableau is saturated.
\end{definition}

For the unconstrained tableau rules, completeness gives us that
an open saturated tableau is satisfiable.
Since the constrained rules only guarantee termination in the
case of finite models, we are not compromising completeness
for termination we have the same guarantee for open saturated tableaux.
As a result, given termination of the tableax and finite models, we
can use the tableaux to check whether the root formula is satisfied
in the model, in particular the process is decidable.
\par
The proof of termination for every tableau construction is adapted from
the proof given in \citet*{bolander2009terminating} for the termination of the
tableau construction algorithm for $\mathcal{H}(@)$.

\begin{definition}
  When a formula $@_s \phi$ occurs in a tableau
  branch $\Theta$ we will write $@_s \phi \in \Theta$,
  and say $\phi$ is true at $s$ on $\Theta$ or
  $s$ makes $\phi$ true on $\Theta$.  
\end{definition}
 
\begin{definition}
  Given a tableau branch $\Theta$ and a nominal
  $s$ the {\it set of true formulae} at $s$ on $\Theta$,
  is written $T^\Theta (s)$ and defined as follows:
  $$T^\Theta (s) = \{ \phi \mid @_s \phi \in \Theta \}$$
\end{definition}

\begin{definition}[{\bf Quasi-subformula}]
  A formula $\phi$ is a {\it quasi-subformula } of a
  formula $\psi$ if one of the the following is the case:
  \begin{enumerate}
  \item
    $\phi$ is a subformula of $\psi$ modulo substitution
    of free variables in $\phi$ for grounded terms.
  \item
    $\phi$ is of the form $\neg \chi$ where $\chi$
    modulo substitution
    of free variables in $\chi$ for grounded terms.
  \end{enumerate}
  Altering the definition to allow grounded terms being substituted
  for free variables ensures compatibility of the following proofs
  with the universal, existential, and \textsf{RR} rules.  
\end{definition}

\begin{definition}[{\bf Accessibility formula}]
  A formula of the form $@_s F t$ or $@_s P t$
  on $\Theta$ is called an
  {\it accessibility formula}
  if it is the first conclusion of an application
  of $F$ or $P$.
\end{definition}


\begin{definition}[{\bf Term equality formula}]
  A formula of the form $@_i t = s$
  where $s$ and $t$ are extended terms
  is called a term equality formula if it is a
  an immediate conclusion of {\bf (ref)}, {\bf (:3)}, or
  {\bf (:func)}, or is generated from such a formula
  by one or more applications of  {\bf (:1)},
  {\bf (:2)}, {\bf (:fix 3)}, or {\bf (:fix 4)}.
\end{definition}

\begin{definition}[{\bf Nominal equality formula}]
  A formula of the form $@_s t$ where
  $s$ and $t$ are nominals is a nominal
  equality formula if it is an immediate conclusion
  of {\bf (:nom ref)} or has such a formula as an ancestor
  on the branch while being an immediate conclusion of
  {\bf (:nom)}
\end{definition}

\begin{definition}[{\bf Root-subformula}]
  Where the root formula of a tableau $\Theta$ is written
  $\textit{root}_{\Theta}$,
  a formula $@_s \phi$ occuring on a tableau $\Theta$
  is called a {\it root-subformula} on $\Theta$
  if it is a quasi-subformula of $\textit{root}_{\Theta}$. 
\end{definition}



\begin{lemma}[{\bf Subformula Property}]
  \label{subformula}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  any formula $@_s \phi$ occuring on $\Theta$
  is either a root-subformula, accessibility
  formula, nominal equality formula, or term equality formula.
\end{lemma}

\begin{proof}
  This is verified by checking the tableau rules.
  We observe the propositional, quantifier, and $@$ rules, along with
  {\bf (:fix 1)}, {\bf (:fix 2)}, and {\bf (:fix 4)} can only take
  root-subformulae as premises and yield root-subformulae as conclusions.
  Definitionally {\bf (ref)}, {\bf (:3)}, and {\bf (:func)}
  generate only term equality formulae
  and {\bf (nom  ref)} generates only nominal equality formulae.
  Whether the premise of {\bf (:2)} is a nominal equality or root-subformula,
  the conclusion is a term equality.  {\bf (:1)} and {\bf (:fix 3)} both preserve
  the ``type'' of their premise, since {\bf (:1)}'s conclusion only changes the nominal
  prefix and if {\bf (:fix 3)}'s premise is a root-subformula then its
  conclusion with its changed terms
  is still a quasi-subformula of the premise by definition.
  \bigskip
  This leaves us with {\bf ($F/P$}), {\bf ($\neg F / \neg P$)},
  {\bf ($F/P$--bridge)}, {\bf (sub)}, and {\bf (nom)}.
  The premise of {\bf ($F/P$}) must be either an accessibility formula or a root subformula,
  in the first case the second conclusion is a nominal equality,
  and in the second case the second conclusion is a root subformula,
  in either case the first conclusion is an accessibility formula.
  In the case of {\bf ($\neg F / \neg P$)}, the first premise can only be
  a root subformula since there's no way to introduce a negation,
  as a result the conclusion must be a root subformula.
  In the case of {\bf ($F/P$--bridge)}, the second premise is
  either an accessibility formula or a root subformula, and since
  the definition of quasi-subformula allows for substitution of (equivalent) nominals,
  the conclusion is the same kind of formula as the second premise.  
  Likewise {\bf (sub)}'s conclusion will be of the same type as its second premise
  since the definition of quasi-subformula allows for substitution of (equivalent) terms.  
  And finally {\bf (nom)}'s conclusion will be of the same type as its second premise
  since the definition of quasi-subformula allows for change of prefix nominals.
\end{proof}

\begin{definition}[$\prec_{\Theta}$]
  \label{prec}
  Where $\Theta$ is a tableau branch in
  the {\it FHTL} calculus, if a nominal $a$
  is introduced to the branch by application of
  of $F$ or $P$
  to a premise $@_s \phi$, we
  say $a$ is {\it generated} by $s$
  on $\Theta$ and write $s \prec_{\Theta} a$.
  We write $\prec_{\Theta}^*$ to denote the reflexive and transitive
  closure of $\prec_{\Theta}$.  
\end{definition}

\begin{definition}[$\textit{Nom}_{\Theta}$]
  The set of nominals and state variables which occur on $\Theta$
  is written $\textit{Nom}_{\Theta}$
\end{definition}

\begin{lemma}
  \label{wellfounded}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  the graph $G = (\textit{Nom}_{\Theta}, \prec_{\Theta})$ is
  a wellfounded finitely branching tree.
\end{lemma}

\begin{proof}
  Each aspect is proved below:
  \begin{itemize}
  \item {\it Wellfoundedness of trees in }$G$
    
    We have that if $a \prec_{\Theta} b$
    then the first occurence of $a$
    on $\Theta$ is before the first occurence
    of $b$, thus by induction any subset of $\textit{Nom}_{\Theta}$ under the relation
    $\prec_{\Theta}$ has a least element and each tree in $G$ is wellfounded.
  \item $G$ {\it is a tree}
    
    Every nominal in $\textit{Nom}_{\Theta}$
    can be generated by at most one other nominal, 
    and every nominal in $\textit{Nom}_{\Theta}$
    must have one of the finitely many nominals in the
    root formula as an ancestor.
  \item $G$ {\it is finitely branching}
    
    We show $G$ is finitely branching by showing that
    given a nominal $a$, there can only be finitely
    many distinct nominals $b$ such that
    $a \prec_{\Theta} b$.
    Each nominal $b$
    such that
    $a \prec_{\Theta} b$
    is generated by applying one of the
    $F$, $P$, $\neg H$, $\neg G$ rules to
    a premise of the form
    $@_i F \phi$, $@_i P \phi$,
    $@_i \neg H \phi$, or $@_i \neg G \phi$
    respectively, where by
    our restrictions, either $\phi$
    is not a nominal, or the entire
    premise is a root subformula.
    Since there can only be finitely
    many root subformulae of the form
    of one of the the possible premises,
    where $i$ is the prefix nominal in each case,
    only finitely many new nominals have been generated
    from $i$.  Thus $G$ is finitely branching.
    
  \end{itemize}
\end{proof}

\begin{lemma}
  \label{inf}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  $\Theta$ is infinite if and only if there exists an infinite
  chain of nominals and state variables
  $a_1 \prec_{\Theta} a_2 \prec_{\Theta} \dotsc \prec_{\Theta} a_n \prec_{\Theta} \dotsc $
\end{lemma}
  
\begin{proof}
  Since the structure of the formulae and tableau rules are not involved
  in the proof from \citet*{bolander2009terminating} holds here as well.
  
  
  \iffalse
  The 'if' direction follows from the observation that the
  talbeau rules can only generate a finite tableau while not
  generating additional nominals, since our conventions
  ensure that all formulae occuring $\Theta$ are distinct.
  For the other direction, first we demonstrate
  $\textit{Nom}_{\Theta}$ is infinite.  Suppose by contradiction
  $\textit{Nom}_{\Theta}$ is finite
  \fi
\end{proof}

\iffalse
The remaining part of the argument for tableau construction
termination is adapted from \citet{areces2009tableaux}.
\fi
\begin{lemma}[{\bf Decreasing length}]
  Let $\Theta$ be a {\it FHTL} tableau branch,
  and $s$ and $t$ are nominals occuring on $\Theta$.
  If $s \prec_{\Theta} t$ then $m_{\Theta}(s) > m_{\Theta}(t)$.
\end{lemma}

\begin{proof}
  Where $\phi$ is a formula of maximal length
  true at $t$ on $\Theta$, we need to show
  $m_{\Theta}(s) > |\phi|$.
  Since $s \prec_{\Theta} t$ 
\end{proof}

\begin{lemma}[{\bf Tableau construction termination}]
  Any tableau in the {\it FHTL} calculus
  is finite.
\end{lemma}

\begin{theorem}
  The satisfiability of a finite set of
  {\it FHTL} sentences in a {\it FHTL}
  model is decidable.
\end{theorem}


\subsection{Decidability}

For our task of AMR inference, we are not concered with the determining the general satisfiability or
validity of an AMR formula translated into {\it FHTL}, but
rather whether it holds in the smallest model consistent with
an established set of {\it FTHL} translations of AMR sentences.
This model will necessarily be finite, since across any finite
number of AMR sentences only a finite number of times and entities
can be referenced. 
In particular, we have a case of a local model-checking problem
where given formula $\phi$, a finite {\it FHTL} model structure $\mathfrak{M}$, a time $t$
in $\mathfrak{M}$, and a variable assignment $g$, we need to determine
whether $\mathfrak{M}, t \vDash_g \phi$ \citep{muller1999model}.
\par
Consequently our use of tableaux for {\it FHTL} formulae will provide
a decision procedure for their satisfiability within a finite model generated
by some set of AMR sentences, rather than their general validity or invalidity,
as is usually the case with tableaux methods.  We develop an approach to using
tableaux as a means of model checking for {\it FHTL}
based on the apporaches in \citet{bhat1998tableau} and \citet{bohn1998first}. 


\section{AMR Interpretation in {\it FHTL}}

\subsection{Examples}

\enumsentence{
  a. Carl filled out the forms and everyone will submit them tomorrow.
  \\
  b.
  \\
  \scriptsize\texttt{(a / and\\
    \hspace*{0.5cm}:op1 (s / scope\\
    \hspace*{1.0cm}:pred (f / fill-out-03 :ongoing - :complete + :time (b / before :op1 (n / now))\\
    \hspace*{1.5cm}:ARG0 (p / person\\
    \hspace*{2.0cm}:name (n2 / name\\
    \hspace*{2.5cm}:op "Carl"))\\
    \hspace*{1.5cm}:ARG1 (f2 / form))\\
    \hspace*{1.0cm}:ARG0 p\\
    \hspace*{1.0cm}:ARG1 f2)\\
    \hspace*{0.5cm}:op2 (s2 / scope\\
    \hspace*{1.0cm}:pred (m / submit-01  :ongoing - :complete + :time (a2 / after :op1 n)\\
    \hspace*{1.5cm}:ARG0 (p2 / person\\
    \hspace*{2.0cm}:mod (a3 / all))\\
    \hspace*{1.5cm}:ARG1 f2)\\
    \hspace*{1.0cm}:ARG0 f2\\
    \hspace*{1.0cm}:ARG1 p2))}
  \\
  c. Technically correct:
  \\
  $@_{\textit{now}} \exists x [\texttt{form}(x) \land P \texttt{fill-out-03}(\texttt{Carl}, x)] \land @_{\textit{now}} \exists x [\texttt{form}(x) \land \forall y [\texttt{person}(y) \to F \texttt{submit-01}(y, x)]]$
  \\
  d. Correct wrt plurality:
  \\
  $@_{\textit{now}} \forall x [\texttt{form}(x) \land P \texttt{fill-out-03}(\texttt{Carl}, x)] \land @_{\textit{now}} \forall x [\texttt{form}(x) \land \forall y [\texttt{person}(y) \to F \texttt{submit-01}(y, x)]]$
  \\
  e. Correct wrt reentrance (but not plurality) (maybe requires the passive for singular case?):
  \\
  $@_{\textit{now}} \exists x [\texttt{form}(x) \land P \texttt{fill-out-03}(\texttt{Carl}, x) \land  \forall y [\texttt{person}(y) \to F \texttt{submit-01}(y, x)]]$
  \\
}
\enumsentence{
a. It was impossible not to notice the car.
\\
b.
\\
\small\texttt{(s / scope\\
  \hspace*{1.0cm}:pred (p / possible-01\\
  \hspace*{1.5cm}:ARG0 (n / notice-01  :ongoing - :complete + :time (b / before :op1 (n2 / now))\\
  \hspace*{2.0cm}:polarity (n3 / not)\\
  \hspace*{2.0cm}:ARG1 (c / car)\\
  \hspace*{1.5cm}:polarity (n4 / not))\\
  \hspace*{1.0cm}:ARG0 n4\\
  \hspace*{1.0cm}:ARG1 p))}
\\
c. Incorrect:
\\
$@_{\textit{now}} \neg F \exists x [\texttt{car}(x) \land \neg P \texttt{notice-01}(x)]$
\\
d. Technically correct:
\\
$@_{\textit{now}} \neg F \exists x [\texttt{car}(x) \land \neg \forall y [ \texttt{person}(y) \to P \texttt{notice-01}(x, y)]]$
\\
e. Correct wrt particularity of the car:
\\
$@_{\textit{now}} \neg F \neg \forall x [ \texttt{person}(y) \to P \texttt{notice-01}(\texttt{car}, y)]]$
\\
}
\smallskip
NB: Will complete these translations in full.
\subsection{Extraction Steps}
With the chosen annotation, the root node
can consist of either a logical connective
(\verb|and|, \verb|or|, or \verb|cond|) linking two
AMR graphs, or a \verb|scope| node with its following
predicate and arguments.      

\subsection{General Extraction Algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \SetKwInput{KwInput}{Input}                % Set the Input
  \SetKwInput{KwOutput}{Output}              % set the Output
  \DontPrintSemicolon

  \KwInput{AMR sentence}
  \KwOutput{{\it FHTL} formula}

  % Set Function Names
  \SetKwFunction{FInterpretEntry}{InterpretEntry}
  \SetKwFunction{FInterpretClause}{InterpretClause}
  \SetKwFunction{FInterpretPred}{InterpretPred}
  \SetKwFunction{FInferArg}{InferArg}
  \SetKwFunction{FRemoveSubgraph}{RemoveSubgraph}
  \SetKwFunction{FTime}{Time}
  \SetKwFunction{FTense}{Tense}
  \SetKwFunction{FPred}{Pred}
  \SetKwFunction{FReference}{Reference}
  \SetKwFunction{FGetArgs}{GetArgs}
  
  \SetKwProg{Fn}{Def}{:}{}
  \Fn{\FInterpretEntry{AMR}}{
    root = Root(AMR)\;
    now = current date/time\;
    \If{root $\in \{ \texttt{and},\texttt{or}, \texttt{cond} \}$}{
      connective = filter(root, $\{ \land, \lor, \to \}$)\;
      clauses = []\;
      \For{\texttt{op} $\in$ Children(root)}{
        append(clauses, \FInterpretClause(\texttt{op}))\;
      }
      \Return $@_{\text{now}}$ join(connective, clauses)\;
    }
    \Return $@_{\text{now}}$ \FInterpretClause(root)\;
  }
  \;

  \Fn{\FInterpretClause{AMR}}{
    time = \FTime(AMR)\;
    nominal = \FReference(time)\;
    tense = \FTense(time)\;
    pred = \FInferArg( \FPred(AMR))(tense)\;
    \Return $@_{\text{nominal}}$ pred(\FGetArgs(AMR))\;
  }
  \;
  
  \Fn{\FInterpretPred{UnaryPred}}{
  }
  \If{hasMods(UnaryPred)}{
    mods = []\;
    \For{mod $\in$ Children(UnaryPred)}{
      append(mods, name(mod)($x$))\;
    }
    FinalPred = $\lambda x .$ join(mods, $\land$)\;
    \Return $\lambda \phi . \exists y . \text{FinalPred}(y) \land \phi(y)$\;
  } \Else{
    FinalPred = $\lambda \phi . \exists x . \text{name(UnaryPred)}(x) \land \phi(x)$\; 
   }
  \;

  \Fn{\FInferArg{PropBankPred}}{
  } 
  \;
  
 \caption{Transform into clauses and connectives.}
\end{algorithm}

\bibliographystyle{acl_natbib}
\bibliography{references}
\end{document}




















































































\iffalse

\begin{lemma}
  \label{root}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  if $@_s t \in \Theta$ where $s$ and $t$ are nominals then $t$
  is a root nominal. 
\end{lemma}

\begin{lemma}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  if $@_s F t \in \Theta$ or $@_s P t \in \Theta$ and
  $t$ is not a root nominal then $s \prec_{\Theta} t$
  or $s$ and $t$ denote the same time.  
\end{lemma}

\begin{definition}[$m_{\Theta}$ and $d_{\Theta}$]
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  $a$ is a nominal/state variable occuring on $\Theta$,
  and $|@_s \phi|$ denotes the length of the formula $@_s \phi$,
  we define $m_{\Theta}(a)$ as:
  $$m_{\Theta}(a) = \max \{|@_s \phi| : @_s \phi \in \Theta \text{ and } @_s \phi \text{ is a root subformula} \}$$
  If there are no root subformulae $@_a \phi$ on $\Theta$ then $m_{\Theta}(a) = - \infty$.
  The {\it depth} of the nominal/state variable $a$ with regard to $\Theta$
  is the length of the unique path in $(\textit{Nom}_{\Theta}, \prec_{\Theta})$
  which connects the root nominal/state variable to $a$. 
\end{definition}

\begin{lemma}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  for any nominal/state variable on
  $\Theta$, $m_{\Theta}(a) \leq |\textit{root}_{\Theta}| - d_{\Theta}(a)$
\end{lemma}

\begin{lemma}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  if for every nominal/state variable $a$ in $\textit{root}_{\Theta}$:
  
  $$ m_{\Theta}(a) \leq |\textit{root}_{\Theta}| - d_{\Theta}(a) $$

  then $\Theta$ is finite.
\end{lemma}

























The proof of the soundness of the tableau method
for {\it FHTL} is adapted from the proof of
soundness of the tableau method for
$\mathcal{H}(@)$ given in \citet*{internalizing}.

\bigskip

We can observe from the tableau rules that
every formula in a tableau is of the
form  $@_s \phi$ or $@_s \neg \phi$.
We call formulae of these forms
{\it satisfaction statements}.
Give a set of satisfaction statements $\Sigma$
and a tableau rule $R$ we develop the
notion of $\Sigma^+$ as an expansion of $\Sigma$
by $R$ as follows based on the different cases for $R$:
\begin{enumerate}
\item

  If $R$ is {\it not} a branching rule, and $R$ takes
  a single formula as input, and $\Sigma^+$ is the set
  obtained by adding to $\Sigma$ the formulae yielded
  by applying $R$ to $\sigma \in \Sigma$,
  then we say $\Sigma^+$ is the result of expanding
  $\Sigma$ by $R$.  
\item

  If $R$ is a binary rule, and $\Sigma^+$ is the set
  obtained by adding to $\Sigma$ the formulae yielded
  by applying $R$ to $\sigma_1 , \sigma_2  , \sigma_2 \in \Sigma$,
  then we say $\Sigma^+$ is the result of expanding
  $\Sigma$ by $R$.
\item

  If $R$ is a branching rule, and $\Sigma^+$ is the set
  obtained by adding to $\Sigma$ the formulae yielded
  by one of the possible outcomes of applying $R$ to $\sigma_1  \in \Sigma$,
  then we say $\Sigma^+$ is the result of expanding
  $\Sigma$ by $R$.
\item

  If a nominal $s$ belongs to some formula in $\Sigma$,
  then $\Sigma^+ = \Sigma \cup \{ @_s s \}$ is
  the result of expanding $\Sigma$ by \textsf{Ref}.
\item
  
  If a nominal $s$ belongs to some formula in $\Sigma$,
  then $\Sigma^+ = \Sigma \cup \{ @_s t = t \}$ is
  the result of expanding $\Sigma$ by $=$-\textsf{Ref}.

\end{enumerate}


\begin{definition}[{\bf Satisfiable by label}]

  Suppose $\Sigma$ is a set of satisfaction statements and
  $\mathfrak{M} = (T, R, D_t, I_{nom}, I_t)_{t \in T}$
  is a standard {\it FHTL} model.
  We say $\Sigma$ is
  {\it satisfied by label} in $\mathfrak{M}$
  under a {\it FHTL} assignment $g$
  if and and only if for all formulae in $\Sigma$:
  \begin{enumerate}
  \item
    If $@_s \phi \in \Sigma$ then
    $\mathfrak{M}, g, I_{nom}(s) \vDash \phi$
  \item
    If $@_s \neg \phi \in \Sigma$ then
    $\mathfrak{M}, g, I_{nom}(s) \not \vDash \phi$
    
  \end{enumerate}

  We say $\Sigma$ is {\it satisfiable by label}
  if and only if there is a standard {\it FHTL} model
  and assignment in which it is satisfied by label.

  
\end{definition}

\begin{theorem}[{\bf Soundness}]
  \label{sound}
  If $\Sigma$ is a set of satisfaction
  statements which is satisfiable by label,
  then for any tableau rule $R$, at least one of the
  sets obtainable by expanding $\Sigma$ by $R$
  is satisfiable by label.  
\end{theorem}


%%\begin{proof}
({\it Proof})  We prove soundness by induction on the
tableau rules, with particular
attention to rules which introduce nominals new
to the branch, namely $\{ F, P, \neg G, \neg H \}$ \cref{fnp},
and rules which introduce new parameters to the branch,
namely the universal rules \cref{univ} and existential rules \cref{ext}.
In all cases discussed below let 
$$\mathfrak{M} = (T, R, D_t, I_{nom}, I_t)_{t \in T}$$
be {\it FHTL} model and $g$ the assignment
in which $\Sigma$ is satisfiable by label.

\begin{itemize}
\item {\it Non-branching Rules}

  We will take the $\land$ rule
  as an example.  Beginning
  from $@_s \phi \land \psi$ we have:
  $$\mathfrak{M}, g, I_{nom}(s) \vDash \phi \land \psi$$
  and consequentially 
  $$\mathfrak{M}, g, I_{nom}(s) \vDash \phi \iff @_s \phi$$
  $$\mathfrak{M}, g, I_{nom}(s) \vDash \psi \iff @_s \psi$$
  Similarly for their negations if at least one of $@_s \phi \land \psi$
  are not satisfied in $\mathfrak{M}$ under $g$.  
  Thus the results of the application of the $\land$ rule, $@_s \phi$ and $@_s \psi$
  are satisfiable in $\mathfrak{M}$ under $g$ and the expansion of $\Sigma$
  by $\land$ is satisfiable by label.
  \bigskip
  The proofs for other non-branching rules are analogous.
\item {\it Binary Rules}
  We will take the $H$ rule
  as an example.  Beginning
  with $@_s H \phi$ and $@_s P t$ we have from the former:
  $$\mathfrak{M}, g, t \vDash \phi \text{ for all } t \in T \text{ such that } R t I_{nom}(s)$$
  and from the latter:
  $$\mathfrak{M}, g, t' \vDash t \text{ for some } t' \in T \text{ such that } R t I_{nom}(s)$$
 
  and consequentially since $Rts$ 
  $$\mathfrak{M}, g, I_{nom}(t) \vDash \phi \iff @_t \phi$$
  Similarly for their negations if at least one of $@_s H \phi$ and $@_s P t$
  are not satisfied in $\mathfrak{M}$ under $g$.
  Thus the result of application of the $H$ rule, $@_t \phi$ is
  satisfiable in $\mathfrak{M}$ under $g$ and the expansion of $\Sigma$
  by $H$ is satisfiable by label.
  \bigskip
  The proofs for other binary rules is analogous.
\item {\it Branching Rules}
  We will take the $\lor$ rule
  as an example.  Beginning
  from $@_s \phi \lor \psi$ if it's satisfied we have:
  $$\mathfrak{M}, g, I_{nom}(s) \vDash \phi \lor \psi$$
  and consequentially at least one of 
  $$\mathfrak{M}, g, I_{nom}(s) \vDash \phi \iff @_s \phi$$
  or 
  $$\mathfrak{M}, g, I_{nom}(s) \vDash \psi \iff @_s \psi$$
  Similarly for their negations if $@_s \phi \lor \psi$ is not satisfied
  in $\mathfrak{M}$ under $g$.
  Thus at least one of the results of the application of the $\lor$ rule,
  $@_s \phi$ or $@_s \psi$ or their negations
  are satisfiable in $\mathfrak{M}$ under $g$ and the expansion of $\Sigma$
  by $\lor$ is satisfiable by label.
  \bigskip
  The proofs for other branching rules are analogous.
\item {\it Existential and Universal Rules}
  We will take the $\forall$ rule
  as an example.  Beginning
  from $@_s \forall x \phi (x)$ if it's satisfied we have
  (where $s' = I_{nom}(s)$):
  $$\mathfrak{M}, g', s' \vDash \phi \text{ for every } x\text{-variant of } g \text{ at } s$$
  That is for every $c$ in $D_{I_{nom}(s)}$, $\phi[t / x]$ is satisfied in $\mathfrak{M}$
  under $g$, similarly for $\neg \phi[t / x]$
  if $@_s \forall x \phi (x)$ is not satisfied
  in $\mathfrak{M}$ under $g$.  
  In accordance with the constraints for the rule we can select $t$ to be any
  grounded term on the branch which is also a member of $D_{I_{nom}(s)}$
  Thus the result of the application of the $\forall$ rule,
  or its negations
  are satisfiable in $\mathfrak{M}$ under $g$ and the expansion of $\Sigma$
  by $\forall$ is satisfiable by label.
  \bigskip
  The proofs for $\exists$, $\neg \exists$, and $\neg \forall$ are analogous.

\item {\it Rules Introducing a Nominal to the Branch}

  We will take the $F$ rule as am example.
  Beginning from $@_s F \phi$, if it's satisfied
  we have:
  $$\mathfrak{M}, g, I_{nom}(s) \vDash \phi \text{ for some } t \in T \text{ such that } R I_{nom}(s) t$$
  Let $a$ denote a nominal such that $R I_{nom}(s) I_{nom}(a)$ as above. As a result we have:
  $$\mathfrak{M}, g, I_{nom}(s) \vDash a \iff$$
  $$\mathfrak{M}, g, t \vDash a  \text{ for some } t \in T \text{ such that } R I_{nom}(s) t \iff$$
  $$\mathfrak{M}, g, I_{nom}(s) = Fa \iff @_s F a$$
  and
  $$\mathfrak{M}, g, I_{nom}(a) \vDash \phi \iff @_a \phi$$
  Similarly for their negations if $@_s F \phi$ is not satisfied in
  $\mathfrak{M}$ under $g$.
  
\item {\it Ref rules}
  $t = t$ is a tautology, invariant of model or assignment.
  For $@_s s$, we begin with having $s$ is the branch,
  as result we certainly have
  $$\mathfrak{M}, g, I_{nom}(s) \vDash I_{nom}(s) \iff @_s s$$
  Thus the expansion of $\Sigma$ by $=-$\textsf{Ref} or \textsf{Ref}
  is satisfiable by label.

  Using this we have demonstrated that the results
  of application of a tableau rule to one or more premises
  reflect the validity or non-validity of the premises. \qed

\end{itemize}

%% Completeness

\begin{definition}[$\sigma_{\Theta}$]
  We fix a function $\sigma$ 
  that to each tableau branch
  and each non-empty subset
  $N \subseteq \textit{Nom}_{\Theta}$
  picks out the element of $N$ which
  denotes the earliest time under the
  accessibility relation $R$ which is
  a total order.  We write the function
  value as $\sigma_{\Theta} N$.
\end{definition}

\begin{definition}[{\bf Urfathers}]
  Let $\Theta$ be a tableau branch
  in the {\it FHTL} calculus and
  let $a$ be a nominal/state variable
  occuring on $\Theta$.  The {\it urfather}
  of $a$ on $\Theta$ written $u_{\Theta} (a)$
  is defined by:
  \[
  u_{\Theta} (a) = 
  \begin{cases}
    \sigma_{\Theta} \{ b | @_a b \in \Theta\},& \text{if } \{ b | @_a b \in \Theta\} \neq \emptyset \\
    a,              & \text{otherwise.}
  \end{cases}
  \]
  a nominal $a$ is called an {\it urfather} on $\Theta$
  if $a = u_{\Theta} (b)$ for some nominal $b$.
\end{definition}

\begin{lemma}
  Where $\Theta$ is a saturated tableau branch
  in the {\it FHTL} calculus, we have the following:
  \begin{itemize}
  \item

    If $@_a \phi$ is a root-subformula not of the form
    $@_a F c$ or $@_a P c$ then $u_{\Theta} (a) \in \Theta$.
  \item

    If $@_a b \in \Theta$ then $u_{\Theta} (a) = u_{\Theta} (b)$
  \item

    If $a$ is an urfather on $\Theta$ then $u_{\Theta} (a) = a$ 
  \end{itemize}
\end{lemma}

\begin{definition}[$\mathfrak{M}^{\Theta}$]
  Where $\Theta$ is a saturated tableau branch
  in the {\it FHTL} calculus, we have following
  model definition:
  $$\mathfrak{M}^{\Theta} = (T^{\Theta}, R^{\Theta}, D_t, I_{nom_{\Theta}}, I_t)_{t \in T^{\Theta}}$$
  from:
 \begin{figure*}[hbt!]
  \centering
  \begin{alignat*}{2}
    & T^{\Theta} && = \{ u_{\Theta} (a) | a \text{ is a nominal/state variable occuring on } \Theta \} \\
    & R^{\Theta} && = \{ (a, u_{\Theta} (b)) \in T^2 | @_a F b \in \Theta \text{ or } @_b P a \in \Theta \} \\
    & I_{nom_{\Theta}}(a) && = I_{nom} (u_{\Theta} (a))
    %%\caption{$AT_x^-$}
  \end{alignat*}

  Finally where $\mathfrak{M}$ had the assignment $g$, we give
  $\mathfrak{M}^{\Theta}$ the assignment $g^{\Theta}$ which is exactly
  like $g$ except for a state variable $s$,
  we have $g^{\Theta} (s) = g (u_{\Theta} (s))$.
  Interpretation of terms is adjusted accordingly. 
\end{figure*}

 
\end{definition}

\begin{theorem}[{\bf Completeness}]
  
\end{theorem}

%%translation stuff

\begin{figure*}[hbt!]
  \centering
  \begin{alignat*}{2}
    & AT_x^- (Px) && := p \\
    & AT_x^- (x = n) && := n \\
    & AT_x^- (x = w) && := w \\
    & AT_x^- (\langle \lambda x . \neg \phi \rangle (x)) && := \neg AT_x^- (\phi) \\
    & AT_x^- (\langle \lambda x . \neg \phi \land \psi \rangle (x)) && := AT_x^- (\phi) \land AT_x^- (\psi) \\
    & AT_x^-(\langle \lambda x . \forall y (Rxy \to \phi) \rangle (x)) && := G AT_y^- (\phi) \\  
    & AT_x^-(\langle \lambda x . \forall y (Ryx \to \phi) \rangle (x)) && := H AT_y^- (\phi) \\
    & AT_x^-(\langle \lambda x . \forall x (x = n \to \phi) \rangle (x)) && := @_n AT_x^- (\phi) \\
    & AT_x^-(P'(x, t_1, \dotsc, t_k)) && := P(t_1, \dotsc, t_k) \\
    & AT_x^-(\langle \lambda x . t_i = t_j \rangle(x)) && := t_i = t_j \\
    & AT_x^- (\langle \lambda x . \forall v  \phi \rangle (x)) && := \forall v AT_x^- (\phi)   
    %%\caption{$AT_x^-^-$}
  \end{alignat*}
  \caption{First-order Formulae to {\it FHTL} Formulae Translation.}
  \label{fol2qhtl}
\end{figure*}

\begin{figure*}[hbt!]
  \centering
  \begin{alignat*}{2}
    & P(t)^* && := @_t p \\
    & (t = u)^* && := @_t u \\
    & (Rst)^* && := @_s F t \\
    & (\langle \lambda x.\phi \rangle (t))^* && := @_t AT_x^- (\langle \lambda x . \phi \rangle (x))\\  
    & (\langle \lambda y.\phi \rangle (t))^* && := @_t AT_y^- (\langle \lambda y . \phi \rangle (y))\\
    & (AT_x(\phi)[t / x])^* && := @_t \phi \\
    & (\neg AT_x(\phi)[t / x])^* && := \neg @_t \phi \\
    & P'(s, t_1, \dotsc, t_k)^* && := @_s P(t_1, \dotsc, t_k) \\
    & (t_i = t_j)^* && := t_i  t_j 
    %% \caption{$AT_x^-^-$}
  \end{alignat*}
  \caption{Translation of First-order Tableau Literals to {\it FHTL} Literals.}
  \label{literal}
\end{figure*}

\fi
