\documentclass[usenames,dvipsnames,pdf]{beamer}

\usepackage{textcomp}
\usepackage{pifont}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsthm}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{multicol}
% \usepackage{tikz}
\usepackage{bussproofs}
\usepackage[tableaux]{prooftrees}
\usepackage{qtree}
\usepackage{mathtools}
\usepackage{scalerel,stackengine}
\usepackage[all]{xy}
% \usetikzlibrary{automata, positioning, shapes, arrows}
% \usepackage[dvipsnames]{xcolor}

\usetheme{CambridgeUS}

%\useoutertheme{miniframes} % Alternatively: miniframes, infolines, split
%\useinnertheme{circles}

\definecolor{UBCblue}{rgb}{0.04706, 0.13725, 0.26667} % UBC Blue (primary)

% \usecolortheme[named=UBCblue]{structure}
% \usecolortheme[named=RoyalBlue]{structure}
\usecolortheme{spruce}
% \usecolortheme{beaver}
%\setbeamercolor{spruce}{fg=cyan!90!black}

\setbeamertemplate{itemize item}{\color{teal}$\blacktriangleright$}
\setbeamertemplate{itemize subitem}{\color{teal}$\blacktriangleright$}


% \newcommand{\newState}[4]{\node[state,#3](#1)[#4]{#2};}
% \newcommand{\newTransition}[4]{\path[->] (#1) edge [#4] node {#3} (#2);} 
\renewcommand*\linenumberstyle[1]{(#1)}
\def\apeqA{\SavedStyle\sim}
\def\apeq{\setstackgap{L}{\dimexpr.5pt+1.5\LMpt}\ensurestackMath{%
  \ThisStyle{\mathrel{\Centerstack{{\apeqA} {\apeqA}}}}}}

\def\dis{\displaystyle}

\def\QQ{\mathbb Q}
\def\ZZ{\mathbb Z}
\def\RR{\mathbb R}
\def\CC{\mathbb C}
\def\FF{\mathbb F}
\def\NN{\mathbb N}
\def\AA{\mathbb A}
\def\II{\mathbb I}

\def\Cc{\mathcal C}
\def\Dd{\mathcal D}
\def\Pp{\mathcal P}

\def\Af{\mathfrak A}
\def\Bf{\mathfrak B}
\def\Cf{\mathfrak C}
\def\Df{\mathfrak D}
\def\Ef{\mathfrak E}
\def\Ff{\mathfrak F}
\def\Gf{\mathfrak G}
\def\Hf{\mathfrak H}
  
% define 2x2 matrix:
\newcommand\twodmatrix[4]{ \ensuremath{ \left( 
	\begin{array}{cc}
		#1 & #2  \\
		#3 & #4 
	\end{array}  
	\right) } }
  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\DeclareMathSymbol{:}{\mathord}{operators}{"3A}

\mode<presentation>{}
%% preamble
\title{Formalizing AMR Inference via Hybrid Logic Tableaux}
\subtitle{CL Masters Thesis Defense}
\author{Eli Goldner}
\begin{document}
	%% title frame
	\begin{frame}
		\titlepage
	\end{frame}


        \section{Overview}

        \begin{frame}{Introduction}
          \begin{itemize}
          \item Semantic representation:
            \begin{itemize}
            \item Capture meaning of natural language content.
            \item Designed for manipulation via software.
            \end{itemize}
          \item Abstract Meaning Representation (AMR):
            \begin{itemize}
            \item Graph-based (DAG), nodes are {\it concepts}, edges are {\it relations}. 
            \item Built on predicative core of a sentence.
            \item Ignores syntactic differences between equivalent sentences.
            \item PropBank framesets are used for concepts (entities, events, properties, states). 
            \end{itemize}
          \end{itemize}
        \end{frame}

        \begin{frame}{Introduction}
          (Basic) AMR is reductionistic.
          This is awesome for:
          \begin{itemize}
          \item
            Annotation (esp. by non-experts).
          \item
            Semantic parsing (smaller target space).  
          \end{itemize}
          This is not awesome for:
          \begin{itemize}
          \item
            Representing and recovering fine-grained meaning.
          \item
            Automating reasoning/inference.
          \end{itemize}
        \end{frame}

        \begin{frame}{Introduction}
          \begin{itemize}
          \item
            The trade-off between ease of generation/use and expressivity/inferentiability is as old as computing\footnote{Possibly as old as cognition.}.
          \item
            AMR has made a choice that works well in data-driven NLP.
          \item
            However AMR can bridge this gap:
            
          \item
            AMR already does this in a modular way with extensions.
          \item
            Some of these extensions give afford interpretation in first-order logic:
            \begin{itemize}
            \item Automated inference for logics is a rich area with lots of tools.
            \item This is where we come in.
            \end{itemize}
          \end{itemize}
        \end{frame}
        
        \begin{frame}{Motivation}
        \end{frame}

        \begin{frame}{Approach}
        \end{frame}
        
        \section{AMR Extensions}

        \begin{frame}{AMR with Tense and Aspect}
        \end{frame}

        \begin{frame}{AMR with Scope}
        \end{frame}

        \section{{\it FHTL}}

        \begin{frame}{Hybrid Logic}
        \end{frame}

        \begin{frame}{Hybrid Logic Variants}
        \end{frame}

        \begin{frame}{First-Order Hybrid Tense Logic}
        \end{frame}
        
        \section{Tableaux}

        \begin{frame}{{\it FHTL} Tableau Example} 
          \begin{tableau}
            [{[f(a,b) = f(b,a)]}
              [@_s (\exists x) {[P((\exists y) {[f(x,y) = f(y,x)]})  \lor \neg (\exists z) {[x = z]}]}
                [@_s P((\exists y) {[f( s_1,y) = f(y, s_1)]})  \lor \neg (\exists z) {[s_1 = z]}
                  [@_s P( (\exists y) {[ f( s_1,y) = f(y, s_1) ]} )
                    [@_s P t
                      [@_t (\exists y) {[ f( s_1,y) = f(y, s_1) ]}
                        [\ldots]
                      ]
                    ]
                  ]
                  [@_s \neg (\exists z) {[s_1 = y]}
                    [@_s \neg {[s_1 = s_1]} 
                      [@_s  {[s_1 = s_1]} , close]
                    ]
                  ]
                ]
              ]
            ]
          \end{tableau}
        \end{frame}


        \begin{frame}{Model Checking Example}
          \begin{itemize}
          \item {\it Every computer will be located at a desk.}
          \item AMR with quantification and tense:

            \small\texttt{(s / scope\\
              \hspace*{1.0cm}:pred (b / be-located-at-91 :ongoing -
              \hspace*{6.155cm}:complete +
              \hspace*{6.155cm}:time (a / after
              \hspace*{8.0cm}:op1 (n / now))\\
              \hspace*{1.5cm}:ARG0 (c / computer)\\
              \hspace*{1.5cm}:ARG1 (d / desk\\
              \hspace*{2.0cm}:quant (e / every)))\\
              \hspace*{1.0cm}:ARG0 d\\
              \hspace*{1.0cm}:ARG1 c)}
            
          \item {\it FHTL} translation:
            
            $@_{\textit{now}} (\forall y) [\text{desk}(y) \to (\exists x) [\text{computer}(x) \land F (\text{be-located-at-91}(x, y))]]$
          \end{itemize}         
        \end{frame}

        \begin{frame}{Model Checking Example}
          Define a small {\it FHTL} model $ \mathfrak{M} = (T, \mathcal{R}, (D_t)_{_{t \in T}}, I_{nom}, (I_t)_{t \in T})$ where:
          $$T = \{ \textit{yesterday}, \textit{now}, \textit{tomorrow} \}$$
          $$\mathcal{R} = \{ (\textit{yesterday}, \textit{now}), (\textit{now}, \textit{tomorrow}), (\textit{yesterday}, \textit{tomorrow})\}$$
          $$I_{nom} = \{ (y, \textit{yesterday}), (n, \textit{now}), (t, \textit{tomorrow})\}$$
          $$D_{\textit{yesterday}} = \{\textit{computer}_1, \textit{desk}_1\}$$
          $$D_{\textit{now}} = \{\textit{computer}_1, \textit{computer}_2, \textit{desk}_1, \textit{desk}_2, \textit{desk}_3 \}$$
          $$D_{\textit{tomorrow}} = \{\textit{computer}_1, \textit{computer}_2, \textit{desk}_1, \textit{desk}_2\}$$
        
        \end{frame}

        \begin{frame}{Model Checking Example}
          \Tree
              [.{$@_n (\forall y) [\text{desk}(y) \to (\exists x) [\text{computer}(x) \land F (\text{located}(x, y))]]$\\
                  $@_n \text{desk}(n:p_1) \to (\exists x) [\text{computer}(x) \land F (\text{located}(x, n:p_1))]$}
                [.{$@_n \neg \text{desk}(n:p_1)$}
                ]
                [.{$@_n (\exists x) [\text{computer}(x) \land F (\text{located}(x, n:p_1))]$\\
                    $@_n \text{computer}(n:p_2) \land F (\text{located}(n:p_2, n:p_1))$\\
                    $@_n \text{computer}(n:p_2)$\\
                    $@_n F (\text{located}(n:p_2, n:p_1))$\\
                    $@_n F s$\\
                    $@_s \text{located}(n:p_2, n:p_1)$}   
               ]
              ]
              

              Where we assign $s = t = \textit{tomorrow}$,
              $n:p_2 = \textit{computer}_1$ and
              $n:p_1 = \textit{desk}_2$, or
              $n:p_2 = \textit{computer}_2$ and
              $n:p_1 = \textit{desk}_1$
              we see that $\mathfrak{M}$ satisfies the {\it FHTL} sentence.
        \end{frame}

          
        
        \section{AMR to {\it FHTL}}

        \begin{frame}{Extraction}
        \end{frame}

        \begin{frame}{Interpretation}
        \end{frame}
        
        \section{Conclusion}
      \end{document}
