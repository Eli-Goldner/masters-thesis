\documentclass[usenames,dvipsnames,pdf]{beamer}

\usepackage{textcomp}
\usepackage{pifont}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsthm}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{cite}
\usepackage{natbib}
% \usepackage{tikz}
\usepackage{bussproofs}
\usepackage{stmaryrd}
\usepackage[tableaux]{prooftrees}
\usepackage{qtree}
\usepackage{mathtools}
\usepackage{scalerel,stackengine}
\usepackage[all]{xy}
% \usetikzlibrary{automata, positioning, shapes, arrows}
% \usepackage[dvipsnames]{xcolor}

\usetheme{CambridgeUS}

%\useoutertheme{miniframes} % Alternatively: miniframes, infolines, split
%\useinnertheme{circles}

\definecolor{UBCblue}{rgb}{0.04706, 0.13725, 0.26667} % UBC Blue (primary)

% \usecolortheme[named=UBCblue]{structure}
% \usecolortheme[named=RoyalBlue]{structure}
\usecolortheme{spruce}
% \usecolortheme{beaver}
%\setbeamercolor{spruce}{fg=cyan!90!black}

\setbeamertemplate{itemize item}{\color{teal}$\blacktriangleright$}
\setbeamertemplate{itemize subitem}{\color{teal}$\blacktriangleright$}

\renewcommand{\phi}{\varphi}

% \newcommand{\newState}[4]{\node[state,#3](#1)[#4]{#2};}
% \newcommand{\newTransition}[4]{\path[->] (#1) edge [#4] node {#3} (#2);} 
\renewcommand*\linenumberstyle[1]{(#1)}
\def\apeqA{\SavedStyle\sim}
\def\apeq{\setstackgap{L}{\dimexpr.5pt+1.5\LMpt}\ensurestackMath{%
  \ThisStyle{\mathrel{\Centerstack{{\apeqA} {\apeqA}}}}}}

\def\dis{\displaystyle}

\def\QQ{\mathbb Q}
\def\ZZ{\mathbb Z}
\def\RR{\mathbb R}
\def\CC{\mathbb C}
\def\FF{\mathbb F}
\def\NN{\mathbb N}
\def\AA{\mathbb A}
\def\II{\mathbb I}

\def\Cc{\mathcal C}
\def\Dd{\mathcal D}
\def\Pp{\mathcal P}

\def\Af{\mathfrak A}
\def\Bf{\mathfrak B}
\def\Cf{\mathfrak C}
\def\Df{\mathfrak D}
\def\Ef{\mathfrak E}
\def\Ff{\mathfrak F}
\def\Gf{\mathfrak G}
\def\Hf{\mathfrak H}
  
% define 2x2 matrix:
\newcommand\twodmatrix[4]{ \ensuremath{ \left( 
	\begin{array}{cc}
		#1 & #2  \\
		#3 & #4 
	\end{array}  
	\right) } }
  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\DeclareMathSymbol{:}{\mathord}{operators}{"3A}

\mode<presentation>{}
%% preamble
\title{Formalizing AMR Inference via Hybrid Logic Tableaux}
\subtitle{CL Masters Thesis Defense}
\author{Eli Goldner}
\begin{document}
	%% title frame
	\begin{frame}
		\titlepage
	\end{frame}


        \section{Overview}

        \begin{frame}{Introduction}
          Semantic representation:
          \begin{itemize}
          \item Capture meaning of natural language content.
          \item Designed for software to manipulate and interpret.
          \end{itemize}
          Abstract Meaning Representation (AMR):
          \begin{itemize}
          \item Graph-based (DAG), nodes are {\it concepts}, edges are {\it relations}. 
          \item Built on predicative core of a sentence.
          \item Ignores syntactic and fine grained semantic differences between sentences.
          \end{itemize}
        \end{frame}
        
        \begin{frame}{Introduction}
          (Core) AMR is reductionistic.
          Optimal for:
          \begin{itemize}
          \item
            Annotation (esp. by non-experts).
          \item
            Semantic parsing (smaller target space).  
          \end{itemize}
          Not optimal for:
          \begin{itemize}
          \item
            Representing and recovering fine-grained meaning.
          \item
            Automating reasoning/inference.
          \end{itemize}
        \end{frame}

        \begin{frame}{Introduction}
          \begin{itemize}
          \item
            AMR designers made a choice that works well in data-driven NLP.
          \item
            Modular AMR extensions.
          \item
            Some extensions afford richer logical interpretation:
          \end{itemize}
        \end{frame}
        
        \begin{frame}{Motivation}

          
          {\it ``Why do we need formal methods? Can't state-of-the-art language models do this already?''}
          \begin{itemize}
          \item
            Statistically driven techniques are unnecessarily expensive for formal inference.
          \item
            Increasing need for ability to guarantee/verify properties of software:
            \begin{itemize}
            \item
              Does the software give us the right {\it type} of result for an input?
            \item
              Bias in NLP.
            \end{itemize}
          \end{itemize}
        \end{frame}

        \begin{frame}{Approach}
          \begin{itemize}
          \item
            Combine two AMR extensions for richer interpretation:
            \begin{itemize}
            \item
              Scope and quantification \citep{pustejovsky-etal-2019-modeling}
            \item
              Tense and aspect \citep{donatelli-etal-2018-annotation}
            \end{itemize}
          \item
            Interpret these extended AMR into a logic that handles quantification and tense.
          \item
            Develop tableau methods for this logic:
            \begin{itemize}
            \item
              General method for proving/disproving sentences in the logic.
            \item
              Restricted method for checking if sentence holds in some model.
            \end{itemize}
          \end{itemize}
        \end{frame}
        
        \section{AMR Extensions}

        \begin{frame}{AMR with Scope and Quantification}
          \begin{itemize}
          \item Disambiguates scope.
          \item Annotates central predicate and its arguments.
          \item Clearest path for AMR $\to$ standard first-order predicate logic. 
          \end{itemize}
        \end{frame}

        \begin{frame}{AMR with Tense and Aspect}
          \begin{itemize}
          \item Standard AMR structure.
          \item Central predicate annotated for:
            \begin{itemize}
            \item Aspect.
            \item Speech time.
            \item Reference time.
            \end{itemize}
          \end{itemize}
        \end{frame}

        \begin{frame}{Combined Extensions}
          \begin{itemize}
          \item Assume each AMR has information from both extensions.
          \item Attach tense and aspect information to central predicate node.
          \item Extract a tense-sensitive FOPL representation (details later).
          \end{itemize}
        \end{frame}
        
        \section{{\it FHTL}}

        \begin{frame}{Modal Logic}
          \begin{itemize}
            \item
          Propositional logic lets us form statements
          like $p \land (q \lor \neg r)$.

          \item
          Modal propositional logic extends
          propositional logic with an operator $\lozenge$
        \item
          It is not possible that
          $p$ and $\neg p$ are the case:
          $$\neg \lozenge (p \land \neg p)$$
        \item
          Meaning of $\lozenge$:
          There is a {\it possible world} where $p$ is true,
          and this possible world is {\it accessible} from the current one.  
        \item
          The problem: the ``current world'' is implicit and dependent on context.
        \item
          How to make it explicit? 
        \end{itemize}
        \end{frame}
        
        \begin{frame}{Hybrid Logic}
          \begin{itemize}
          \item
            Extend propositional modal logic,
            with the operator $@$, which specifies the world we're referring to.
          \item
            $p$ or $r$ is possible at world $i$:
            $$@_i \lozenge (p \lor r)$$
          \item
            In the above proposition $i$ is called a nominal since
            it {\it names} some/is true at exactly one world.
          \item
            Everything true at the nominal $j$ is true at the nominal $i$
            (they name the same world): $@_i j$
          \end{itemize}
        \end{frame}

        \begin{frame}{Hybrid Logic Variants}
          Hybrid tense logic:
          \begin{itemize}
          \item Two tense modalities: $F$ and $P$
          \item World $j$ is in the past of world $i$: $@_i P j$
          \end{itemize}
          Quantified hybrid logic:
          \begin{itemize}
          \item Hybrid logic with first-order quantifiers, relation, and function symbols.
          \item At $n$ (now) there is a person for whom it is possible to own a car:
            $$@_n (\exists x)(\textit{Person}(x) \land (\exists y) (\textit{Car}(y) \land \lozenge \textit{Afford}(x,y)))$$
          \end{itemize}
        \end{frame}
        
        \begin{frame}{Hybrid Logic Variants}
          A problem
          $$@_n (\exists x)(\textit{Person}(x) \land (\exists y) (\textit{Car}(y) \land \lozenge \textit{Afford}(x,y)))$$
          What's the domain of quantification?
          \begin{itemize}
          \item
            Option 1: The domain is the same at every world:
            {\it There is someone (out of all people all people at all worlds) who can afford some car (out of all cars at all worlds).}
          \item
            Option 2: Each world has a different domain:
            {\it There is someone (out of everyone in this world) who can afford some car (out of all cars in this world).}\end{itemize}
        \end{frame}

        \begin{frame}{Hybrid Logic Variants}
          \begin{itemize}
          \item
            We tend to mean there is some person (and more loosely some car) here/now. 
          \item
            Option 2 is closer to how quantification works in natural language. 
          \item
            We use this approach (presentist quantification).
          \end{itemize}
        \end{frame}
        
        \begin{frame}{First-Order Hybrid Tense Logic}
          First-order Hybrid Tense Logic ({\it FHTL}) is:
          \begin{itemize}
          \item Quantified hybrid logic, with tense modalities $F$ and $P$ instead of $\lozenge$.
          \item Presentist quantification:
            \begin{itemize}
            \item Each world has its own domain.
            \item Quantification is domain sensitive.
            \end{itemize}
          \end{itemize}    
        \end{frame}

        \begin{frame}{First-Order Hybrid Tense Logic}
          In logic models are interpretations of symbols and constants in the language.
          An {\it FHTL} model $\mathfrak{M}$ is a tuple
          $$(T, \mathcal{R}, (D_t)_{_{t \in T}}, I_{nom}, (I_t)_{t \in T})$$
          Where:
          \begin{itemize}
          \item $T$ is a set of times/worlds.
          \item $\mathcal{R}$ is the binary accessibility relation over times.
          \item $D_t$ is the domain of a time $t$
          \item $I_{nom}$ assigns nominals to worlds.
          \item $I_t$ interprets the value of terms at a time $t$.
          \end{itemize}
        \end{frame}
        
        \begin{frame}{First-Order Hybrid Tense Logic}
          \begin{itemize}
          \item
            The satisfiability of a formula with free variables depends on a {\it variable assignment function}.
          \item
            A formula with no free variables is called a {\it sentence}.
          \end{itemize}
          Two main tasks for a sentence $@_s \phi$:
          \begin{itemize}
          \item Theorem proving -- is $@_s \phi$ true regardless of the model?
          \item Model checking -- is $@_s \phi$ true in a given model $\mathfrak{M}$?
          \end{itemize}
          For both we use versions of the tableau method.
        \end{frame}
        
        \section{Tableaux}

        \begin{frame}{Tableau Method}
          \begin{itemize}
          \item
            Tableau for a formula is a tree structure.
          \item
            A tableau calculus for a logic breaks down and transforms formulae
          \item
            Rules of the calculus use semantics of connectives/quantifiers/modifiers.
          \item
            {\it FHTL} tableau based on {\it QHL} tableau modified for tense rules.
          \end{itemize}
        \end{frame}

        \begin{frame}{Tableau Method}
          \begin{itemize}
          \item
            A tableau branch is a subtree of the main tableau tree.
          \item
            A tableau {\it branches} for rules involving
            disjunctions.
          \item
            A branch is {\it closed} if it contains both a formula
            $@_s \phi$ and its negation $@_s \neg \phi$. Otherwise it is open.
          \item
            A branch is {\it saturated} if no rules of the calculus can be applied
            without adding a redundant formula on the branch.  
          \end{itemize}
        \end{frame}

        \begin{frame}{Tableau Example Rules}
          \begin{multicols}{2}
            \begin{prooftree}
              \AxiomC{$@_s F \phi$}
              \RightLabel{\bf ($F$)\footnote{\label{intro}The nominal $a$ is new to the branch.}\footnote{\label{nom}The formula $\phi$ is not a nominal.}}
              \UnaryInfC{$@_s F a$}
              \noLine
              \UnaryInfC{$@_a \phi$}
            \end{prooftree}

            \begin{prooftree}
              \AxiomC{$@_s (\exists x) \phi$}
              \RightLabel{\bf ($\exists$)\footnote{$s : p$ is new to the branch.}}
              \UnaryInfC{$@_s \phi[s:p / x]$} 
            \end{prooftree}
          \end{multicols}

          \begin{multicols}{2}
            \begin{prooftree}
              \AxiomC{$@_s @_t \phi$}
              \RightLabel{\bf ($@$)}
              \UnaryInfC{$@_t \phi$} 
            \end{prooftree}

            \begin{prooftree}
              \AxiomC{$@_i j:t = k:s$}
              \AxiomC{$@_i \phi$}
              \RightLabel{\bf (sub)\footnote{\label{subst}$\phi[j:t // k:s]$ is $\phi$ where some occurences of $j:t$ have been replaced by $k:s$.}}
              \BinaryInfC{$@_i \phi[j:t // k:s]$} 
            \end{prooftree}
          \end{multicols}
        \end{frame}
        
        \begin{frame}{{\it FHTL} Tableau Example} 
          \begin{tableau}
            [%%{[f(a,b) = f(b,a)]}
              [@_s (\exists x) {[P((\exists y) {[f(x,y) = f(y,x)]})  \lor \neg (\exists z) {[x = z]}]}
                [@_s P((\exists y) {[f( s_1,y) = f(y, s_1)]})  \lor \neg (\exists z) {[s_1 = z]}
                  [@_s P( (\exists y) {[ f( s_1,y) = f(y, s_1) ]} )
                    [@_s P t
                      [@_t (\exists y) {[ f( s_1,y) = f(y, s_1) ]}
                        [\ldots]
                      ]
                    ]
                  ]
                  [@_s \neg (\exists z) {[s_1 = z]}
                    [@_s \neg {[s_1 = s_1]} 
                      [@_s  {[s_1 = s_1]} , close]
                    ]
                  ]
                ]
              ]
            ]
          \end{tableau}
        \end{frame}

        \begin{frame}{Tableau Proofs}
          \begin{itemize}
          \item
            The {\it root formula} of a tableau is unsatisfiable
            if every branch of the tableau closes.
          \item
            If we want to prove $@_s \phi$ then
            we begin the tableau with $@_s \neg \phi$
            (proof by contradiction).
          \item
            Need to show for tableau method
            (or any proof system) that it is:
            \begin{itemize}
            \item
              Sound -- if a tableau is closed then the root formula is unsatisfiable.
            \item
              Complete -- if a formula is unsatisfiable it has a closed tableau proof. 
            \end{itemize}
          \end{itemize}
        \end{frame}

        \begin{frame}{Tableau Proofs}
          \begin{itemize}
          \item
            Soundness is demonstrated by checking the rules.
          \item
            Completeness is demonstrated by contrapositive.
            
          \item
            Open tableau branch $\to$ there is a model which satisfies the root.
          \item
            Construct the model out of equivalence classes of everything that shows up on the branch.
          \end{itemize}
        \end{frame}

        \begin{frame}{Tableaux for Model Checking}
          \begin{itemize}
          \item
            So far the tableau method has been about general theorem proving.
          \item
            Problem: no tableau construction method guaranteed to terminate (if there was we'd have decidability of first-order logic).
          \item
            Most of the time however we are reasoning about an AMR/{\it FHTL} sentence in some local context.
          \item
            Revise tableau rules, trade completeness for termination.
          \end{itemize}
        \end{frame}

        \begin{frame}{Tableaux for Model Checking}
          NB:  Terms in {\it FHTL} have nominal prefixes
          since their value can depend on the world they are evaluated in,
          i.e. $i:t$, $i:j:t$.
          There are three things that prevent tableau construction from terminating: 
          \begin{itemize}
          \item
            Universal tableau rules ($\neg \exists$, $\forall$) -- can generate an arbitrary number of conclusions.
          \item
            Term rules -- can keep adding prefixes to terms.
          \item
            Nominal rules -- generating redundant nominals (our complete rules take care of this). 
          \end{itemize}
        \end{frame}

        \begin{frame}
          \begin{itemize}
          \item
            Idea: give tableau a reasonable chance to close, but make sure it terminates.
          \item
            Fix some $q \in \NN^+$ and let universal rules generate at most $q$ conclusions.
            (\citet*{fitting-tab} says $q = 1$ works surprisingly often.)
          \item
            Restrict term rules to depend on nominals and terms already on the branch.
            Prevent redundant prefixes (no $i:j:i:t$ etc.).
          \end{itemize}
        \end{frame}

        \begin{frame}
          Model checking procedure
          \begin{itemize}
          \item
            Build tableau using restricted rules.
          \item
            Check tableau tree from leaves up, skipping closed branches.
          \item
            Every formula on the branch has a set of variable and parameter assignments which satisfy it in the model.
          \item
            Solve for a formula's set based on the sets of its conclusions.
          \item
            If the root formula is satisfied in the model by every variable assignment then it holds.
          \end{itemize}
        \end{frame}
        
        \begin{frame}{Model Checking Example}
          \begin{itemize}
          \item {\it Every desk will have a computer located there.}
          \item AMR with quantification and tense:

            \small\texttt{(s / scope\\
              \hspace*{1.0cm}:pred (b / be-located-at-91 :ongoing -
              \hspace*{6.155cm}:complete +
              \hspace*{6.155cm}:time (a / after
              \hspace*{8.0cm}:op1 (n / now))\\
              \hspace*{1.5cm}:ARG0 (c / computer)\\
              \hspace*{1.5cm}:ARG1 (d / desk\\
              \hspace*{2.0cm}:quant (e / every)))\\
              \hspace*{1.0cm}:ARG0 d\\
              \hspace*{1.0cm}:ARG1 c)}
            
          \item {\it FHTL} translation:
            
            $@_{\textit{now}} (\forall y) [\text{desk}(y) \to (\exists x) [\text{computer}(x) \land F (\text{be-located-at-91}(x, y))]]$
          \end{itemize}         
        \end{frame}

        \begin{frame}{Model Checking Example}
          Define a small {\it FHTL} model $ \mathfrak{M} = (T, \mathcal{R}, (D_t)_{_{t \in T}}, I_{nom}, (I_t)_{t \in T})$ where:
          $$T = \{ \textit{yesterday}, \textit{now}, \textit{tomorrow} \}$$
          $$\mathcal{R} = \{ (\textit{yesterday}, \textit{now}), (\textit{now}, \textit{tomorrow}), (\textit{yesterday}, \textit{tomorrow})\}$$
          $$I_{nom} = \{ (y, \textit{yesterday}), (n, \textit{now}), (t, \textit{tomorrow})\}$$
          $$I_{\textit{yesterday}}(\texttt{be-located-at-91}) = \ldots$$
          $$I_{\textit{now}}(\texttt{be-located-at-91}) = \ldots$$
          $$I_{\textit{tomorrow}}(\texttt{be-located-at-91}) = \{ \langle \textit{computer}_1,  \textit{desk}_2 \rangle, \langle \textit{computer}_2,  \textit{desk}_1 \rangle \}$$
          $$D_{\textit{yesterday}} = \{\textit{computer}_1, \textit{desk}_1\}$$
          $$D_{\textit{now}} = \{\textit{computer}_1, \textit{computer}_2, \textit{desk}_1, \textit{desk}_2, \textit{desk}_3 \}$$
          $$D_{\textit{tomorrow}} = \{\textit{computer}_1, \textit{computer}_2, \textit{desk}_1, \textit{desk}_2\}$$
        
        \end{frame}

        \begin{frame}{Model Checking Example}
          \Tree
              [.{$@_n (\forall y) [\text{desk}(y) \to (\exists x) [\text{computer}(x) \land F (\text{located}(x, y))]]$\\
                  $@_n \text{desk}(n:p_1) \to (\exists x) [\text{computer}(x) \land F (\text{located}(x, n:p_1))]$}
                [.{$@_n \neg \text{desk}(n:p_1)$}
                ]
                [.{$@_n (\exists x) [\text{computer}(x) \land F (\text{located}(x, n:p_1))]$\\
                    $@_n \text{computer}(n:p_2) \land F (\text{located}(n:p_2, n:p_1))$\\
                    $@_n \text{computer}(n:p_2)$\\
                    $@_n F (\text{located}(n:p_2, n:p_1))$\\
                    $@_n F s$\\
                    $@_s \text{located}(n:p_2, n:p_1)$}   
               ]
              ]
              

              Where we assign $s = t = \textit{tomorrow}$,
              $n:p_2 = \textit{computer}_1$ and
              $n:p_1 = \textit{desk}_2$, or
              $n:p_2 = \textit{computer}_2$ and
              $n:p_1 = \textit{desk}_1$
              we see that $\mathfrak{M}$ satisfies the {\it FHTL} sentence.
        \end{frame}

          
        
        \section{AMR to {\it FHTL}}

        \begin{frame}{Extraction}
          In this new annotation time information is of the form:
          
          \texttt{:<aspect> <polarity> :time (<reference> :op1 (<speech>))}
          
          \begin{itemize}
          \item
            \texttt{<speech>} is some $t \in T$, so formula has the prefix $@_t \phi$
          \item
            \texttt{<reference>} (if present) is the tense, e.g. $@_t P \psi$
          \item
            We don't make use of aspect (right now).
          \end{itemize}
          
        \end{frame}

        
        \begin{frame}{Interpretation}
          Every AMR in this annotation is either of the
          form (for a connective \texttt{or}, \texttt{and}, or \texttt{cond}):


          \scriptsize\texttt{(<connective>\\
            \hspace*{0.5cm}:op1 (...)\\
            \hspace*{0.5cm}:op2 (...)\\
            \hspace*{0.5cm}:op3 (...))}
          
          Or

          \scriptsize\texttt{(s / scope\\
            \hspace*{1.0cm}:pred (...\\
            \hspace*{1.5cm}:ARG0 (...)\\
            \hspace*{1.5cm}:ARG1 (...))\\
            \hspace*{1.0cm}:ARG0 <primary-scope>\\
            \hspace*{1.0cm}:ARG1 <secondary-scope>)}
  
        \end{frame}

        \begin{frame}{Interpretation Examples}
          
          \scriptsize\texttt{(o / or\\
            \hspace*{0.5cm}:op1 (...)\\
            \hspace*{0.5cm}:op2 (...)\\
            \hspace*{0.5cm}:op3 (...))}
          $$\llbracket \texttt{op1} \rrbracket \lor \llbracket \texttt{op2} \rrbracket \lor \llbracket \texttt{op3} \rrbracket$$

          \scriptsize\texttt{(s / scope\\
            \hspace*{1.0cm}:pred (...\\
            \hspace*{1.5cm}:ARG0 (...)\\
            \hspace*{1.5cm}:ARG1 (...))\\
            \hspace*{1.0cm}:ARG0 <primary-scope>\\
            \hspace*{1.0cm}:ARG1 <secondary-scope>)}
          $$\llbracket \texttt{<primary-scope>} \rrbracket(\llbracket \texttt{<secondary-scope>} \rrbracket (\llbracket \texttt{pred} \rrbracket))$$  
        \end{frame}

        \begin{frame}{Interpretation Examples}
          \small\texttt{(s / scope\\
            \hspace*{1.0cm}:pred (b / be-located-at-91 :ongoing -
            \hspace*{6.155cm}:complete +
            \hspace*{6.155cm}:time (a / after
            \hspace*{8.0cm}:op1 (n / now))\\
            \hspace*{1.5cm}:ARG0 (c / computer)\\
            \hspace*{1.5cm}:ARG1 (d / desk\\
            \hspace*{2.0cm}:quant (e / every)))\\
            \hspace*{1.0cm}:ARG0 d\\
            \hspace*{1.0cm}:ARG1 c)}

          $$@_{\textit{now}} (\forall y) [\text{desk}(y) \to (\exists x) [\text{computer}(x) \land F (\text{be-located-at-91}(x, y))]]$$
          
        \end{frame}

        \begin{frame}

          $$\llbracket \texttt{now} \rrbracket \rhd \textit{now}$$
          $$\llbracket \texttt{after} \rrbracket \rhd F$$
          
          \texttt{(c / computer)}
          $$\lambda \phi . (\exists x) [\textit{Computer}(x) \land \phi(x)]$$
          \texttt{(d / desk\\
            \hspace*{1.0cm}:quant (e/ every))}
          $$\lambda \phi . (\forall x) [\textit{Desk}(x) \to \phi(x)]$$          
        \end{frame}

        \begin{frame}{Interpretation Example}
          \small\texttt{(:pred (b / be-located-at-91 :ongoing -
            \hspace*{5.155cm}:complete +
            \hspace*{5.155cm}:time (a / after
            \hspace*{7.0cm}:op1 (n / now))} 

          $$\lambda \phi . \lambda x . \lambda y . \phi(\texttt{be-located-at-91}(x,y))$$
        \end{frame}

        \begin{frame}{Interpretation Example}
          First application:
          $$\llbracket \textit{computer will be located at it} \rrbracket = $$
          \scriptsize$$\lambda \phi . (\lambda \phi' . (\exists c) [\textit{Computer}(c) \land \phi'(c)])(\lambda \psi . (\lambda \psi' . \psi' (\lambda x . \lambda y . F (\textit{loc}(x,y))))(\lambda \gamma . \phi(\gamma(\psi)))) \rhd_{\beta}$$
          \small$$\lambda \phi . (\exists c) [\textit{Computer}(c) \land ((\lambda \psi' . \psi' (\lambda x . \lambda y . F (\textit{loc}(x,y)))) (\lambda \gamma . \phi(\gamma(c))))] \rhd_{\beta}$$
          \small$$\lambda \phi . (\exists c) [\textit{Computer}(c) \land \phi ( \lambda y . F (\textit{loc}(c,y)))]$$
        \end{frame}

        \begin{frame}{Interpretation Example}
          Second application:
          \small$$\lambda \phi . \llbracket \textit{every desk} \rrbracket (\lambda \psi \llbracket \textit{computer will be located at it} \rrbracket (\lambda \gamma . \phi (\psi (\psi)))) \rhd_{\beta}$$
          \small$$\lambda \phi . (\lambda \phi' . \forall x [\textit{Desk}(x) \to \phi'(x)]) (\lambda \psi \llbracket \textit{computer located at it} \rrbracket (\lambda \gamma . \phi (\gamma (\psi))))$$
          \small$$\lambda \phi . (\forall x) [\textit{Desk}(x) \to (\llbracket \textit{computer located at it} \rrbracket (\lambda \gamma . \phi (\gamma (x))))] = $$
          \small$$\lambda \phi . (\forall x) [\textit{Desk}(x) \to ((\lambda \phi' . (\exists y) (\textit{computer}(c) \land (\phi ( \lambda x . F (\textit{loc}(y,x)))))  (\lambda \gamma . \phi (\gamma (x))))]$$
          \small$$\lambda \phi . (\forall x) [\textit{Desk}(x) \to (\exists y) [\textit{Computer}(y) \land \phi(F (\textit{loc}(x,y)))]]$$
        \end{frame}

        \begin{frame}{Interpretation Example}
          Use the trivial continuation $\lambda k . k$:
          $$(\lambda \phi . (\forall x) [\textit{Desk}(x) \to (\exists y) [\textit{Computer}(y) \land \phi(F ( \textit{loc}(x,y)))]]) (\lambda k . k) \rhd_{\beta}$$
          $$(\forall x) [\textit{Desk}(x) \to (\exists y) [\textit{Computer}(y) \land F ( \textit{loc}(x,y))]]$$
          Finally attaching the nominal:
          $$@_{\textit{now}}(\forall x) [\textit{Desk}(x) \to (\exists y) [\textit{Computer}(y) \land F ( \textit{loc}(x,y))]]$$
     
        \end{frame}
        
        \section{Conclusion}

        \begin{frame}{Conclusion}
          \begin{itemize}
          \item
           We explored how AMR can benefit from formal inference.
          \item
            Described a combination of AMR extensions.
          \item
            Sketched a first-order hybrid logic variant with general proof procedure and model checking methods.
          \item
            Demonstrated how sentences are handled by these methods.
          \item
            Showed how AMR sentences can be translated into {\it FHTL} 
          \end{itemize}
        \end{frame}

        \begin{frame}[allowframebreaks]
          \frametitle{References}
          \bibliographystyle{acl}
          \nocite{quantified}
          \nocite{hansen2007tableau} 
          \nocite{bolander2009terminating}
          \nocite{bolander2007termination}
          \nocite{hungar1995if}
          \nocite{bhat1998tableau}
          \bibliography{references}
        \end{frame}
      \end{document}
      
      