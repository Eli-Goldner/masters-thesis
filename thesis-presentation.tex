\documentclass[usenames,dvipsnames,pdf]{beamer}

\usepackage{textcomp}
\usepackage{pifont}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsthm}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{cite}
\usepackage{natbib}
% \usepackage{tikz}
\usepackage{bussproofs}
\usepackage[tableaux]{prooftrees}
\usepackage{qtree}
\usepackage{mathtools}
\usepackage{scalerel,stackengine}
\usepackage[all]{xy}
% \usetikzlibrary{automata, positioning, shapes, arrows}
% \usepackage[dvipsnames]{xcolor}

\usetheme{CambridgeUS}

%\useoutertheme{miniframes} % Alternatively: miniframes, infolines, split
%\useinnertheme{circles}

\definecolor{UBCblue}{rgb}{0.04706, 0.13725, 0.26667} % UBC Blue (primary)

% \usecolortheme[named=UBCblue]{structure}
% \usecolortheme[named=RoyalBlue]{structure}
\usecolortheme{spruce}
% \usecolortheme{beaver}
%\setbeamercolor{spruce}{fg=cyan!90!black}

\setbeamertemplate{itemize item}{\color{teal}$\blacktriangleright$}
\setbeamertemplate{itemize subitem}{\color{teal}$\blacktriangleright$}


% \newcommand{\newState}[4]{\node[state,#3](#1)[#4]{#2};}
% \newcommand{\newTransition}[4]{\path[->] (#1) edge [#4] node {#3} (#2);} 
\renewcommand*\linenumberstyle[1]{(#1)}
\def\apeqA{\SavedStyle\sim}
\def\apeq{\setstackgap{L}{\dimexpr.5pt+1.5\LMpt}\ensurestackMath{%
  \ThisStyle{\mathrel{\Centerstack{{\apeqA} {\apeqA}}}}}}

\def\dis{\displaystyle}

\def\QQ{\mathbb Q}
\def\ZZ{\mathbb Z}
\def\RR{\mathbb R}
\def\CC{\mathbb C}
\def\FF{\mathbb F}
\def\NN{\mathbb N}
\def\AA{\mathbb A}
\def\II{\mathbb I}

\def\Cc{\mathcal C}
\def\Dd{\mathcal D}
\def\Pp{\mathcal P}

\def\Af{\mathfrak A}
\def\Bf{\mathfrak B}
\def\Cf{\mathfrak C}
\def\Df{\mathfrak D}
\def\Ef{\mathfrak E}
\def\Ff{\mathfrak F}
\def\Gf{\mathfrak G}
\def\Hf{\mathfrak H}
  
% define 2x2 matrix:
\newcommand\twodmatrix[4]{ \ensuremath{ \left( 
	\begin{array}{cc}
		#1 & #2  \\
		#3 & #4 
	\end{array}  
	\right) } }
  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\DeclareMathSymbol{:}{\mathord}{operators}{"3A}

\mode<presentation>{}
%% preamble
\title{Formalizing AMR Inference via Hybrid Logic Tableaux}
\subtitle{CL Masters Thesis Defense}
\author{Eli Goldner}
\begin{document}
	%% title frame
	\begin{frame}
		\titlepage
	\end{frame}


        \section{Overview}

        \begin{frame}{Introduction}
          \begin{itemize}
          \item Semantic representation:
            \begin{itemize}
            \item Capture meaning of natural language content.
            \item Designed for manipulation via software.
            \end{itemize}
          \item Abstract Meaning Representation (AMR):
            \begin{itemize}
            \item Graph-based (DAG), nodes are {\it concepts}, edges are {\it relations}. 
            \item Built on predicative core of a sentence.
            \item Ignores syntactic differences between equivalent sentences.
            \item PropBank framesets are used for concepts (entities, events, properties, states). 
            \end{itemize}
          \end{itemize}
        \end{frame}

        \begin{frame}{Introduction}
          (Basic) AMR is reductionistic.
          This is awesome for:
          \begin{itemize}
          \item
            Annotation (esp. by non-experts).
          \item
            Semantic parsing (smaller target space).  
          \end{itemize}
          This is not awesome for:
          \begin{itemize}
          \item
            Representing and recovering fine-grained meaning.
          \item
            Automating reasoning/inference.
          \end{itemize}
        \end{frame}

        \begin{frame}{Introduction}
          \begin{itemize}
          \item
            The trade-off between ease of generation/use and rich expressivity/inferentiability is at least as old as computing.
          \item
            AMR has made a choice that works well in data-driven NLP.
          \item
            However AMR can bridge this gap:
            
          \item
            AMR already does this in a modular way with extensions.
          \item
            Some of these extensions give afford interpretation in first-order logic:
            \begin{itemize}
            \item Automated inference for logics is a rich area with lots of tools.
            \item This is where we come in.
            \end{itemize}
          \end{itemize}
        \end{frame}
        
        \begin{frame}{Motivation}

          
          {\it ``Why do we need formal methods? Can't state-of-the-art language models do this already?''}

          Short answer: Not really, and even if they could:
          \begin{itemize}
          \item
            Statistically driven techniques are unecessarily expensive for formal inference.
          \item
            Increasing need for ability to guarantee/verify properties of software:
            \begin{itemize}
            \item
              Does the software give us the right {\it type} of result for an input?
            \item
              Bias in NLP.
            \end{itemize}
          \item
            Machine learning (by itself) does not lend itself well to this.
          \end{itemize}
        \end{frame}

        \begin{frame}{Approach}
          \begin{itemize}
          \item
            Combine two AMR extensions for richer interpretation:
            \begin{itemize}
            \item
              Scope and quantification \citep{pustejovsky-etal-2019-modeling}
            \item
              Tense and aspect \citep{donatelli-etal-2018-annotation}
            \end{itemize}
          \item
            Interpret these extended AMR into a logic that handles quantification and tense.
          \item
            Develop tableau methods for this logic:
            \begin{itemize}
            \item
              General method for proving/disproving sentences in the logic.
            \item
              Restricted method for checking if sentence holds in some model.
            \end{itemize}
          \end{itemize}
        \end{frame}
        
        \section{AMR Extensions}

        \begin{frame}{AMR with Scope and Quantification}
          \begin{itemize}
          \item Disambiguates scope.
          \item Annotates central predicate and its arguments.
          \item Clearest path for AMR $\to$ standard first-order predicate logic. 
          \end{itemize}
        \end{frame}

        \begin{frame}{AMR with Tense and Aspect}
          \begin{itemize}
          \item Standard AMR structure.
          \item Central predicate annotated for:
            \begin{itemize}
            \item Aspect.
            \item Event time.
            \item Reference time.
            \end{itemize}
          \end{itemize}
        \end{frame}

        \begin{frame}{Combined Extensions}
          \begin{itemize}
          \item Assume each AMR has information from both extensions.
          \item Attach tense and aspect information to central predicate node.
          \item Extract a tense-sensitive FOPL representation (details later).
          \end{itemize}
        \end{frame}
        
        \section{{\it FHTL}}

        \begin{frame}{Modal Logic}
          \begin{itemize}
            \item
          Propositional logic lets us form statements
          like $p \land (q \lor \neg r)$.

          \item
          Modal propositional logic extends
          propositional logic with an operator $\lozenge$,
          read as ``possible''.  i.e. it is not possible that
          $p$ and $\neg p$ are the case would be:
          $$\neg \lozenge (p \land \neg p)$$
        \item
          (More) formal meaning of $\lozenge$:
          There is a {\it possible world} where $p$ is true,
          and this possible world is {\it accesible} from the current one.  
        \item
          The problem: the ``current world'' is an implicit notion dependent on context.  Is there something more expressive? 
        \end{itemize}
        \end{frame}
        
        \begin{frame}{Hybrid Logic}
          \begin{itemize}
          \item
            Idea: take propositional modal logic,
            and add an operator $@$, that lets us know which world we're referring to.
          \item
            $p$ or $r$ is possible at world $i$: $@_i \lozenge (p \lor r)$
          \item
            In the above proposition $i$ is called a nominal since
            it {\it names} some/is true at exactly one world.
          \item
            Everything true at the nominal $j$ is true at the nominal $i$
            (they name the same world): $@_i j$
          \end{itemize}
        \end{frame}

        \begin{frame}{Hybrid Logic Variants}
          \begin{itemize}
          \item Hybrid tense logic:
            \begin{itemize}
            \item Two tense modalities: $\langle F \rangle$ and $\langle P \rangle$
            \item World $j$ is in the past of world $i$: $@_i P j$
            \end{itemize}
          \item Quantified hybrid logic:
            \begin{itemize}
            \item Hybrid logic with first-order quantifiers, relation, and function symbols.
            \item At $n$ (now) there is a person for whom it is possible to own a car:
              $$@_n (\exists x)(\textit{Person}(x) \land (\exists y) (\textit{Car}(y) \land \lozenge \textit{Afford}(x,y)))$$
            \end{itemize}
          \end{itemize}
        \end{frame}

        \begin{frame}{Hybrid Logic Variants}
          A problem
          $$@_n (\exists x)(\textit{Person}(x) \land (\exists y) (\textit{Car}(y) \land \lozenge \textit{Afford}(x,y)))$$
          What's the domain of quantification?
          \begin{itemize}
          \item
            Option 1: The domain is the same at every world:
            {\it There is someone (out of all people all people at all worlds) who can afford some car (out of all cars at all worlds).}
          \item
            Option 2: Each world has a different domain:
            {\it There is someone (out of everyone in this world) who can afford some car (out of all cars in this world).}
          \end{itemize}
          The first option in quantified hybrid (or modal) logic is called possibilist quantification, the second is called actualist.
          When worlds are interpreted as times, the former is called eternalist quantification, and the latter is callled presentist.
          We will use presentist quantification.
        \end{frame}
        
        \begin{frame}{First-Order Hybrid Tense Logic}
          First-order Hybrid Tense Logic ({\it FHTL}) is:
          \begin{itemize}
          \item Quantified hybrid logic, with tense modalities $F$ and $P$ instead of $\lozenge$.
          \item Presentist quantification:
            \begin{itemize}
            \item Each world has its own domain.
            \item Quantification is domain sensitive.
            \end{itemize}
          \end{itemize}    
        \end{frame}

        \begin{frame}{First-Order Hybrid Tense Logic}
          In logic models are interpretations of symbols and constants in the language.
          An {\it FHTL} model $\mathfrak{M}$ is a tuple
          $$(T, \mathcal{R}, (D_t)_{_{t \in T}}, I_{nom}, (I_t)_{t \in T})$$
          Where:
          \begin{itemize}
          \item $T$ is a set of times/worlds.
          \item $\mathcal{R}$ is the binary accesibility relation over times.
          \item $D_t$ is the domain of a time $t$
          \item $I_{nom}$ assigns nominals to worlds.
          \item $I_t$ interprets the value of terms at a time $t$.
          \end{itemize}
          The satisfiability of a formula with free variables depends on a variable assignment function.
          A formula that does not depend on variable assignment (every variable is bound by a quantifier)
          is called a {\it sentence}. 
         \end{frame}

        \begin{frame}{First-Order Hybrid Tense Logic}
          \begin{itemize}
          \item Two main tasks for a sentence $s$:
            \begin{itemize}
            \item Theorem proving -- is $s$ true regardless of the model?
            \item Model checking -- is $s$ true in some model $\mathfrak{M}$?
            \end{itemize}
          \item For both we use versions of the tableau method.
          \end{itemize}    
          
        \end{frame}
        
        \section{Tableaux}

        \begin{frame}{{\it FHTL} Tableau Example} 
          \begin{tableau}
            [{[f(a,b) = f(b,a)]}
              [@_s (\exists x) {[P((\exists y) {[f(x,y) = f(y,x)]})  \lor \neg (\exists z) {[x = z]}]}
                [@_s P((\exists y) {[f( s_1,y) = f(y, s_1)]})  \lor \neg (\exists z) {[s_1 = z]}
                  [@_s P( (\exists y) {[ f( s_1,y) = f(y, s_1) ]} )
                    [@_s P t
                      [@_t (\exists y) {[ f( s_1,y) = f(y, s_1) ]}
                        [\ldots]
                      ]
                    ]
                  ]
                  [@_s \neg (\exists z) {[s_1 = y]}
                    [@_s \neg {[s_1 = s_1]} 
                      [@_s  {[s_1 = s_1]} , close]
                    ]
                  ]
                ]
              ]
            ]
          \end{tableau}
        \end{frame}


        \begin{frame}{Model Checking Example}
          \begin{itemize}
          \item {\it Every computer will be located at a desk.}
          \item AMR with quantification and tense:

            \small\texttt{(s / scope\\
              \hspace*{1.0cm}:pred (b / be-located-at-91 :ongoing -
              \hspace*{6.155cm}:complete +
              \hspace*{6.155cm}:time (a / after
              \hspace*{8.0cm}:op1 (n / now))\\
              \hspace*{1.5cm}:ARG0 (c / computer)\\
              \hspace*{1.5cm}:ARG1 (d / desk\\
              \hspace*{2.0cm}:quant (e / every)))\\
              \hspace*{1.0cm}:ARG0 d\\
              \hspace*{1.0cm}:ARG1 c)}
            
          \item {\it FHTL} translation:
            
            $@_{\textit{now}} (\forall y) [\text{desk}(y) \to (\exists x) [\text{computer}(x) \land F (\text{be-located-at-91}(x, y))]]$
          \end{itemize}         
        \end{frame}

        \begin{frame}{Model Checking Example}
          Define a small {\it FHTL} model $ \mathfrak{M} = (T, \mathcal{R}, (D_t)_{_{t \in T}}, I_{nom}, (I_t)_{t \in T})$ where:
          $$T = \{ \textit{yesterday}, \textit{now}, \textit{tomorrow} \}$$
          $$\mathcal{R} = \{ (\textit{yesterday}, \textit{now}), (\textit{now}, \textit{tomorrow}), (\textit{yesterday}, \textit{tomorrow})\}$$
          $$I_{nom} = \{ (y, \textit{yesterday}), (n, \textit{now}), (t, \textit{tomorrow})\}$$
          $$D_{\textit{yesterday}} = \{\textit{computer}_1, \textit{desk}_1\}$$
          $$D_{\textit{now}} = \{\textit{computer}_1, \textit{computer}_2, \textit{desk}_1, \textit{desk}_2, \textit{desk}_3 \}$$
          $$D_{\textit{tomorrow}} = \{\textit{computer}_1, \textit{computer}_2, \textit{desk}_1, \textit{desk}_2\}$$
        
        \end{frame}

        \begin{frame}{Model Checking Example}
          \Tree
              [.{$@_n (\forall y) [\text{desk}(y) \to (\exists x) [\text{computer}(x) \land F (\text{located}(x, y))]]$\\
                  $@_n \text{desk}(n:p_1) \to (\exists x) [\text{computer}(x) \land F (\text{located}(x, n:p_1))]$}
                [.{$@_n \neg \text{desk}(n:p_1)$}
                ]
                [.{$@_n (\exists x) [\text{computer}(x) \land F (\text{located}(x, n:p_1))]$\\
                    $@_n \text{computer}(n:p_2) \land F (\text{located}(n:p_2, n:p_1))$\\
                    $@_n \text{computer}(n:p_2)$\\
                    $@_n F (\text{located}(n:p_2, n:p_1))$\\
                    $@_n F s$\\
                    $@_s \text{located}(n:p_2, n:p_1)$}   
               ]
              ]
              

              Where we assign $s = t = \textit{tomorrow}$,
              $n:p_2 = \textit{computer}_1$ and
              $n:p_1 = \textit{desk}_2$, or
              $n:p_2 = \textit{computer}_2$ and
              $n:p_1 = \textit{desk}_1$
              we see that $\mathfrak{M}$ satisfies the {\it FHTL} sentence.
        \end{frame}

          
        
        \section{AMR to {\it FHTL}}

        \begin{frame}{Extraction}
        \end{frame}

        \begin{frame}{Interpretation}
        \end{frame}
        
        \section{Conclusion}

        \begin{frame}[allowframebreaks]
          \frametitle{References}
          \bibliographystyle{acl}
          \bibliography{references}
        \end{frame}
      \end{document}
