% 
% File acl2019.tex
%
%% Based on the style files for ACL 2018, NAACL 2018/19, which were
%% Based on the style files for ACL-2015, with some improvements
%%  taken from the NAACL-2016 style
%% Based on the style files for ACL-2014, which were, in turn,
%% based on ACL-2013, ACL-2012, ACL-2011, ACL-2010, ACL-IJCNLP-2009,
%% EACL-2009, IJCNLP-2008...
%% Based on the style files for EACL 2006 by 
%%e.agirre@ehu.es or Sergi.Balari@uab.es
%% and that of ACL 08 by Joakim Nivre and Noah Smith

\documentclass[11pt]{article}
%%\usepackage[hyperref]{acl2021}
\usepackage{times}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{lingstyle}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{bussproofs}
\usepackage{multicol}
%%\usepackage{prftree.sty} 
\usepackage{natbib}
\usepackage{cite}
\usepackage{float}
\usepackage{turnstile}
\usepackage{rotating}
%%\usepackage{stfloats}
\usepackage{subcaption}

\usepackage{graphicx}
\usepackage{framed}

\usepackage[margin=0.5in]{geometry}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{corollary}{Corollary}


\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\theoremstyle{remark}
\newtheorem*{remark}{Remark}


\usetikzlibrary{arrows,positioning,shapes} 
\tikzset{
    %Define standard arrow tip
    >=stealth',
    %Define style for boxes
    amrnode/.style={
             ellipse,
             draw=black, very thick,
             font=\small},
    scopenode/.style={
             ellipse,
             draw=red, very thick, dashed,
             text=red,
             font=\small},
    % Define arrow style
    amrarrow/.style={
            ->,
            thick,
            font=\small},
    scopearrow/.style={
              ->,
              red,
              thick,
              dashed,
              font=\small}
}



 \def\drs#1#2{\begin{tabular}{|l|}\hline #1 \\ \hline \\
                [-8pt] #2\\[-8pt] \\ \hline \end{tabular} }

 \def\ddrs#1{\begin{tabular}{||c||}\hline \\
                [-8pt] #1\\[-8pt] \\ \hline \end{tabular} }

 \def\topdrs#1#2{\begin{tabular}{|l|}\hline #1 \\ \hline \\
                [-8pt] #2 \\[-8pt] \\ \hline \end{tabular} }

 \def\proof#1#2#3#4{\drs{#1}{#2} \ $\vdash$ \ \drs{#3}{#4}}
 \def\modimp#1#2#3#4{\mbox{\drs{#1}{#2} \ $\Box$ \ \drs{#3}{#4}}}
 \def\imp#1#2#3#4{\drs{#1}{#2} \ $\Rightarrow$ \ \drs{#3}{#4}}
 \def\dis#1#2#3#4{\mbox{\drs{#1}{#2} \ $\vee$ \ \drs{#3}{#4}}}
 \def\int#1#2{\mbox{$^{\wedge}$ \ \drs{#1}{#2}}}
 \def\pos#1#2{\mbox{$\Diamond$ \ \drs{#1}{#2}}}
 \def\nec#1#2{\mbox{$\Box$ \ \drs{#1}{#2}}}
 \def\nega#1#2{\mbox{$\neg$ \ \drs{#1}{#2}}}
 \def\pred#1#2#3{\mbox{#1\ :\drs{#2}{#3}}}


\usepackage{url} 

\usepackage[acronym]{glossaries} % 'nomain' to disable automatic generation of "glossary" section 
\glsdisablehyper % disable hyperlink to non-existing glossary section 
%\aclfinalcopy % Uncomment this line for the final submission
%\def\aclpaperid{***} %  Enter the acl Paper ID here

%\setlength\titlebox{5cm}
% You can expand the titlebox if you need extra space
% to show all the authors. Please do not make the titlebox
% smaller than 5cm (the original size); we will check this
% in the camera-ready version and ask you to change it back.

\newcommand\BibTeX{B\textsc{ib}\TeX}

\title{Formalization of AMR Inference via Hybrid Logic Tableaux}
 

 
\author{
  Eli Goldner
}
\begin{document}
\maketitle
\begin{abstract}
  AMR and its extensions have become popular in semantic representation due
  to their ease of annotation by non-experts, attention to the predicative core of sentences,
  and abstraction away from various syntactic matter.
  An area where AMR and its extensions warrant improvement is formalization
  and suitability for inference, where it is lacking compared to
  other semantic representations, such as
  description logics, episodic logic, and discourse representation theory.
  This thesis presents a formalization of inference over a merging of
  \citeauthor{donatelli-etal-2018-annotation}'s \citeyearpar{donatelli-etal-2018-annotation} AMR extension for tense and aspect
  and with \citeauthor{pustejovsky-etal-2019-modeling}'s \citeyearpar{pustejovsky-etal-2019-modeling} AMR extension for quantification and scope.
  Inference is modeled with a merging of Blackburn and Marx's tableau method for quantified hybrid logic
  ({\it QHL}) and Blackburn and J{\o}rgensen's tableau method for basic hybrid tense logic ({\it BHTL}).
  We motivate the merging of these AMR variants,
  present their interpretation and inference in the combination of {\it QHL}
  and {\it BHTL}, which we will call {\it QHTL} (quantified hybrid tense logic),
  and demonstrate {\it QHTL}'s soundess, completeness,
  and decidability. 
  
\end{abstract}


\section{Introduction}

\section{Related Work}

We draw from a number of areas which motivate this approach, namely
designing semantic representations for inferentiability,
the history and goals of AMR and its different annotations,
and hybrid logic with its variants and their accompanying tableaux methods for proof.  

\subsection{Inference in Semantic Representation}

Semantic representation is the task of representing meaning at the sentential
and potentially the discourse levels of language in a formally specifiable way.

\subsection{Discourse Representation Theory}

Discourse representation theory was developed in 1981 by Hans Kamp \citep{kampdiscourse}
and a simlar theory independently
in 1982 by Irene Heim under the name of {\it File Change Semantics} (FCS)
\citep{Heim1982-HEITSO-4}. 


Discourse representation theory (DRT) uses discourse representation structures (DRS)
to represent a listeners understanding of the discourse content as it develops over time.

A DRS has two main components:
\begin{itemize}
\item
  A set of {\it referents}, representing entities which are in the discourse. 
\item
  A set of {\it conditions}, representing information about the discourse referents.
\end{itemize}

For instance, the single sentence {\it The farmer saw the rancher.} admits the DRS:
\enumsentence{
  {[ $x$, $y$ : farmer($x$), rancher($y$), saw($x$,$y$)]}
  \label{DRS1}}

The conditions in \ref{DRS1} are {\it simple},
that is they do not take the form of DRSs or constructions of DRSs,
an example of a DRS with complex conditionals, would be for the
sentence {\it If a farmer owns a dog, they feed it.}

\enumsentence{
  $[_{1}  x$ : farmer($x$),
  
  $[_{2} y$ : dog($y$), owns($x$, $y$) $\to$ $[_{3}  v, w $ : feeds($v$, $w$) $]]]$  
\label{DRS2}}

\subsubsection{Segmented Discourse Representation Theory}

\subsection{Description Logics}

More expressive than propositional logic, less expressive than first-order logic.
Examples: OWL-DL \citep{Pellet}, \citep{OWL}.  

A DL models {\it concepts}, {\it roles}, and {\it individuals},
and relationships among them .

DL relates roles and concepts via {\it axioms}, the key modeling concept of DL,
in contrast to frame spacifications in AI which declare and completely define classes \citep{GRAU2008309}.

First DL-based knowledge representation system was KL-ONE \citep{KL-ONE}.

Other 1980s DL systems -- {\it substructural subsumption algorithms},
lower expressivity but polynomial time reasoning \citep[Chapter~3]{van2008handbook}.

Introduction of tableaux based algorithms in 90s allowed greater efficiency on
problems in more expressive DL.

Modern DL \citep{Pellet} \citep{FaCT++} and RacerPro \citep{HHMW12} (from Racer \citep{HaMo01a})

Advantages:  Comparatively expressive but still decidable, good for domain specific knowledge.

Disadvantages:  Not expressive enough for semantic representation of language, designed to be
a knowledge representation \citep{SR_Schubert2015}.  

\subsection{Situation Semantics and Related}

\subsubsection{Situation Semantics}

\subsubsection{Type Theory with Records}

\subsubsection{PTT}

\subsubsection{KoS}

\subsection{Episodic Logic}

Episodic Logic is a Montague-style logical form based semantic representation
and knowledge representation, 
with relative strength in semantic expressivity and inferetiability
in comparison to other semantic representation, making it better comparatively better suited
for deep NLU \citep{KK_Schubert2015}.  Episodic Logic allows for generalized quantifiers,
lambda abstraction,
reification and modification of sentences and predicates, intensional predicates,
unreliable generalizations, and explicit situational variables \citep{schubert-00}.
Episodic Logic with its inference engine {\sc Epilog} provide a way to capture
a relatively comprehensive range of semantic phenomena compared
to other SR/KRs, in a way which affords inference about semantic data
at a comparable efficiency with automated
inference engines for first order logic \citep{KK_Schubert2015}.  It also has an associated knowledge base
{\sc Knext} which is capable of parsing sentences into factoids,
generalizing them (through a process called quantificational sharpening),
and making certain judgements about whether a generalized factoid
is redudant or inconsistent with anything established in the knowledge base.

\subsection{Semantic Features in AMR and Possbility of Inference}

%% Reference UMR?

Separating argument structure in AMR from logical structure, enables
translation from AMR to DRT \citep{bos-2020-separating}

AMR expressivity without recurrent variables
(and with no more than one universal quantifier per sentence)
are in the decidable two-variable fragment of first-order logic \citep{bos-2016-squib}

Extension of sentential AMR to incorporate a coarse grained
treatment of tense and aspect \citep{donatelli-etal-2018-annotation}

Continuation based semantics for translating AMR into first-order
logic in a way that preserves projection phenomena such as quantification,
negation, bound variables, and donkey anaphora, which better affords
inference than other first-order logic semantics for AMR \citep{lai-etal-2020-continuation}.



\subsection{Hybrid Logic and Our Chosen Semantic Features}

\section{Merging AMR Annotations}

\subsection{AMR Annotated for Tense and Aspect}

\subsection{AMR Annotated for Scope and Quantification}


\section{Merging Quantified Hybrid Logic and Indexical Hybrid Tense Logic}

\subsection{Background}

\subsection{Quantified Hybrid Logic}

\subsection{Basic Hybrid Tense Logic}

\section{Quantified Hybrid Tense Logic - Syntax and Semantics}
\smallskip
The syntax of {\it QHTL} is identical to {\it QHL} as given in \citet*{quantified} except
uses of $\downarrow$ as in $\downarrow w . \phi$ are omitted along
with $\Box$ and $\Diamond$ as in $\Box \phi$ and $\Diamond \phi$.
$\Box$ and $\Diamond$ are replaced by their semantic equivalents
$F$ and $G$ and their temporal duals $P$ and $H$ are added.

\smallskip


Atomic formulae are the same as in {\it QHL}, symbols in \textsf{NOM}
and \textsf{SVAR} together with first-order atomic formulae
generated from the predicate symbols and equality over the terms. 
Thus complex formulae are generated from the atomic formulae according to the
following rules:
$$\neg \phi | \phi \land \psi | \phi \lor \psi | \phi \to \psi | \exists x \phi | \forall x \phi | F \phi | G \phi | P \phi | H \phi | @_n \phi $$



Since we want the domain of quantification to be indexed
over the collection of nominals/times, we look to
\citeauthor{fitting-modal}'s \citeyearpar{fitting-modal}
treatment of first-order modal logic with varying domain semantics
and use it to alter the {\it QHL} model definition
to the following:
$$(T, R, D_t, I_{nom}, I_t)_{t \in T}$$
Thus with varying domain semantics a {\it QHTL}
model is identical to the definition for a {\it QHL} model in that:
\begin{itemize}
  \item
    $(T,R)$ is a modal frame.
  \item
    $I_{nom}$ is a function assigning members of $T$ to nominals.
\end{itemize}

The differences manifest on the level of the model and
interpretation.  Namely, where $D = \cup_{t \in T} D_t$,
$(D, I_t)$ is a first-order model where:
\begin{itemize}
\item
  $I_t (q) \in D$ where $q$ is a unary function symbol.
\item
  $I_t (P) \in D^k$ where $P$ is a $k$-ary predicate symbol.
\end{itemize}

Notice we've relaxed the requirement that $I_t (c) = I_{t'} (c)$ for
$c$ a constant and $t,t' \in T$, since the interpretation of the
constant need not exist at both times.  This permits us to distinguish
between the domain of a frame and the domain of a time/world,
in a way that prevents a variable $x$ from failing to refer
at a given time/world, even if it has no interpretation at that time.
Intuitively this permits {\it QHTL} to handle interpretation of entities
in natural language utterances, which while reasonable to refer to
do not exist at a current time, e.g. previous and future presidents.


\smallskip

Free variables are handled similarly as in {\it QHL}.
Where again $D = \cup_{t \in T} D_t $, a {\it QHTL} assignment is a function:
$$g : \textsf{SVAR} \cup \textsf{FVAR} \to T \cup D $$
Where state variables are sent to times/worlds and
first-order variables are sent to $D$, the domain
of the frame.
Thus given a model and an assignment $g$,
the interpretation of terms $t$ denoted by $\overline{t}$
is defined as:
\begin{itemize}
\item
  $\overline{x} = g(x)$ for $x$ a variable.
\item
  $\overline{c} = I_t (c)$ for $c$ a constant and some $t \in T$.
\item For $q$ a unary function symbol:
  \begin{itemize} 
  \item
    For $n$ a nominal:
    $$\overline{@_n q} = I_{I_{nom}(n)} (q)$$
  \item
    For $n$ a state variable:
    $$\overline{@_n q} = I_{g(n)} (q)$$
  \end{itemize}
\end{itemize}

Finally we say an assignment $g'$ is an $x$-variant of $g$ if $g'$
and $g$ on all variables except possiblly $x$.
In particular, we say $g'$ is an $x$-variant of $g$ at $t$, a time, if $g'$
and $g$ on all variables except possiblly $x$ and $g'(x) \in D_t$.
Given a model $\mathfrak{M}$, a variable assignment $g$,
and a state $s$, the inductive definition is:

\begin{alignat*}{2}
  &\mathfrak{M}, g, s \dststile{}{} P(t_1, \dotsc , t_n )  && \Longleftrightarrow \langle \overline{t_1}, \dotsc , \overline{t_n} \rangle \in I_s (P)  \\
  &\mathfrak{M}, g, s \dststile{}{} t_i = t_j  && \Longleftrightarrow \overline{t_i} = \overline{t_j}  \\
  &\mathfrak{M}, g, s \dststile{}{} n && \Longleftrightarrow I_{nom} (n) = s, \text{for }n\text{ a nominal}  \\
  & \mathfrak{M}, g, s \dststile{}{} w && \Longleftrightarrow g(w) = s, \text{for }w\text{ a state variable}  \\
  & \mathfrak{M}, g, s \dststile{}{} \neg \phi && \Longleftrightarrow  \mathfrak{M}, g, s \not\dststile{}{} \phi \\
  & \mathfrak{M}, g, s \dststile{}{} \phi \land \psi && \Longleftrightarrow  \mathfrak{M}, g, s \dststile{}{} \phi \text{ and } \mathfrak{M}, g, s \dststile{}{} \psi \\
  & \mathfrak{M}, g, s \dststile{}{} \phi \lor \psi && \Longleftrightarrow  \mathfrak{M}, g, s \dststile{}{} \phi \text{ or } \mathfrak{M}, g, s \dststile{}{} \psi \\
  & \mathfrak{M}, g, s \dststile{}{} \phi \to \psi && \Longleftrightarrow  \mathfrak{M}, g, s \dststile{}{} \phi \text{ implies } \mathfrak{M}, g, s \dststile{}{} \psi \\
  & \mathfrak{M}, g, s \dststile{}{} \exists x \phi && \Longleftrightarrow \mathfrak{M}, g', s \dststile{}{} \phi \text{ for some } x\text{-variant }g'\text{ of } g \text{ at } s \\
  & \mathfrak{M}, g, s \dststile{}{} \forall x \phi && \Longleftrightarrow \mathfrak{M}, g', s \dststile{}{} \phi  \text{ for some } x\text{-variant }g'\text{ of } g \text{ at } s \\
  & \mathfrak{M}, g, s \dststile{}{} F \phi && \Longleftrightarrow \mathfrak{M}, g, t \dststile{}{} \phi \text{ for some } t \in T \text{ such that } Rst \\
  & \mathfrak{M}, g, s \dststile{}{} G \phi && \Longleftrightarrow \mathfrak{M}, g, t \dststile{}{} \phi \text{ for all } t \in T \text{ such that } Rst \\
  & \mathfrak{M}, g, s \dststile{}{} P \phi && \Longleftrightarrow \mathfrak{M}, g, t \dststile{}{} \phi \text{ for some } t \in T \text{ such that } Rts \\
  & \mathfrak{M}, g, s \dststile{}{} H \phi && \Longleftrightarrow \mathfrak{M}, g, t \dststile{}{} \phi \text{ for all } t \in T \text{ such that } Rts \\
  & \mathfrak{M}, g, s \dststile{}{} @_n \phi && \Longleftrightarrow \mathfrak{M}, g, I_{nom}(n) \dststile{}{} \phi \text{ for } n \text{ a nominal } \\
  & \mathfrak{M}, g, s \dststile{}{} @_w \phi && \Longleftrightarrow \mathfrak{M}, g, g(w) \dststile{}{} \phi \text{ for } w \text{ a state variable }
  %%\caption{$AT_x$}
\end{alignat*}

\subsection{The Tableau Calculus}



\begin{figure*}[hbt!]
  \begin{framed}
    \centering
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s \neg \phi$}
        \RightLabel{$[\neg]$}
        \UnaryInfC{$\neg @_s \phi$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$\neg @_s \neg \phi$}
        \RightLabel{$[\neg \neg]$}
        \UnaryInfC{$@_s \phi$}
      \end{prooftree}
    \end{multicols}
    \caption{Negation rules}
  \end{framed}
\end{figure*}

\begin{figure*}[hbt!]
  \begin{framed}
  \centering
  \begin{multicols}{3}
    \begin{prooftree}
      \AxiomC{$@_s (\phi \land \psi)$}
      \RightLabel{$[\land]$}
      \UnaryInfC{$ @_s \phi$}
      \noLine
      \UnaryInfC{$ @_s \psi$}
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$\neg @_s (\phi \lor \psi)$}
      \RightLabel{$[\neg \lor]$}
      \UnaryInfC{$\neg @_s \phi$}
      \noLine
      \UnaryInfC{$\neg @_s \psi$}
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$\neg @_s (\phi \to \psi)$}
      \RightLabel{$[\neg \to]$}
      \UnaryInfC{$@_s \phi$}
      \noLine
      \UnaryInfC{$\neg @_s \psi$}
    \end{prooftree}
  \end{multicols}
  \caption{Conjunctive rules.}
\end{framed}
\end{figure*}

\begin{figure*}[hbt!]
  \begin{framed}
  \centering
  \begin{multicols}{3}
    \begin{prooftree}
      \AxiomC{$@_s (\phi \lor \psi)$}
      \RightLabel{$[\lor]$}
      \UnaryInfC{$@_s \phi \mid @_s \psi$} 
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$\neg @_s (\phi \land \psi)$}
      \RightLabel{$[\neg \land]$}
      \UnaryInfC{$\neg @_s \phi \mid \neg @_s \psi$}
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$@_s (\phi \to \psi)$}
      \RightLabel{$[\to]$}
      \UnaryInfC{$\neg @_s \phi \mid @_s \psi$}
    \end{prooftree}
  \end{multicols}
  \caption{Disjunctive rules.}
\end{framed}
\end{figure*}


\begin{figure*}
  \begin{framed}
    \centering
    \begin{multicols}{4}
      \begin{prooftree}
        \AxiomC{$@_s @_t \phi$}
        \RightLabel{$[@]$}
        \UnaryInfC{$@_t \phi$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$\neg @_s @_t \phi$}
        \RightLabel{$[\neg @]$}
        \UnaryInfC{$\neg @_t \phi$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$[s\text{ on the branch}]$}
        \RightLabel{$[\textsf{Ref}]$}
        \UnaryInfC{$@_s s$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_t s$}
        \RightLabel{$[\textsf{Sym}]$}
        \UnaryInfC{$@_s t$}
      \end{prooftree}
    \end{multicols}
    
    
    \begin{multicols}{4}
      \begin{prooftree}
        \AxiomC{$@_s P t$}
        \RightLabel{$[P\textsf{--Trans}]$}
        \UnaryInfC{$@_t F s$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s F t$}
        \RightLabel{$[F\textsf{--Trans}]$}
        \UnaryInfC{$@_t P s$}  
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s P t$}
        \AxiomC{$@_t u$}
        \RightLabel{$P\textsf{--Bridge}$}
        \BinaryInfC{$@_s P u$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s F t$}
        \AxiomC{$@_t u$}
        \RightLabel{$F\textsf{--Bridge}$}
        \BinaryInfC{$@_s F u$}  
      \end{prooftree}
    \end{multicols}
    
    \begin{multicols}{3}
      \begin{prooftree}
        \AxiomC{$@_s t$}
        \AxiomC{$@_s \phi$}
        \RightLabel{$[\textsf{Nom}]$}
        \BinaryInfC{$@_t \phi$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s t$}
        \AxiomC{$@_t \phi$}
        \RightLabel{$[\textsf{Nom}^{-1}]$}
        \BinaryInfC{$@_s \phi$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s t$}
        \AxiomC{$@_t r$}
        \RightLabel{$[\textsf{Trans}]$}
        \BinaryInfC{$@_s r$} 
      \end{prooftree} 
    \end{multicols}
    \caption{@ rules}
  \end{framed}
\end{figure*}

 
\begin{figure*}
  \begin{framed}
  \begin{multicols}{2}
    \begin{prooftree}
      \AxiomC{$@_s F \phi$}
      \RightLabel{$[F]$}
      \UnaryInfC{$@_s F a$}
      \noLine
      \UnaryInfC{$@_a \phi$}
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$@_s P \phi$}
      \RightLabel{$[P]$}
      \UnaryInfC{$@_s P a$}
      \noLine
      \UnaryInfC{$@_a \phi$}
    \end{prooftree}
  \end{multicols}
  
  \begin{multicols}{2}
    \begin{prooftree}
      \AxiomC{$\neg @_s G \phi$}
      \RightLabel{$[\neg G]$}
      \UnaryInfC{$@_s F a$}
      \noLine
      \UnaryInfC{$\neg @_a \phi$} 
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$\neg @_s H \phi$}
      \RightLabel{$[\neg H]$}
      \UnaryInfC{$@_s P a$}
      \noLine
      \UnaryInfC{$\neg @_a \phi$} 
    \end{prooftree}
  \end{multicols}
  \caption{$F$ and $P$ rules}
  \label{fnp}
  \end{framed}
\end{figure*}

\begin{figure*}[hbt!]
  \begin{framed}
  \centering
  \begin{multicols}{2}
    \begin{prooftree}
      \AxiomC{$@_s H \phi$}
      \AxiomC{$@_s P t$}
      \RightLabel{$[H]$}
      \BinaryInfC{$@_t \phi$} 
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$@_s G \phi$}
      \AxiomC{$@_s F t$}
      \RightLabel{$[G]$}
      \BinaryInfC{$@_t \phi$}
    \end{prooftree}
  \end{multicols}
  \caption{$G$ and $H$ rules}
\end{framed}
\end{figure*}

Following \citet*{fitting-modal} we assume for each nominal $s$,
there is an infinite list of parameters, where parameters are free variables
which are never quantified over, arranged in such a way that different nominals
never share the same parameter.  Informally we write $p_s$ to indicate
a parameter is associated with a nominal $s$.  
\par
We also introduce the notion of a grounded term.  A grounded term
is either a first-order constant, a parameter,
or a grounded definite description, i.e.
a term of the form $@_n q$ for $n$ a nominal
and $q$ a unary function symbol.
\begin{figure*}[hbt!]
  \begin{framed}
  \begin{multicols}{2}
    \begin{prooftree}
      \AxiomC{$@_s \exists x \phi(x)$}
      \RightLabel{$[\exists]$}
      \UnaryInfC{$@_s \phi(p_s)$} 
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$@_s \neg \forall x \phi(x)$}
      \RightLabel{$[\neg \forall]$}
      \UnaryInfC{$\neg @_s \phi(p_s)$}
    \end{prooftree}
  \end{multicols}
  \caption{Existential rules}
  \label{ext}
  \end{framed}
\end{figure*}

In the existential rules \ref{ext}, $p_s$ is a parameter associated with the
nominal $s$, with the constraint that it is new to the branch.
Since parameters are never quantified over,
$p_s$ is free in $\phi[p_s / x]$.

%% \begin{figure*}[!hbt]
\begin{figure*}[H]
  \begin{framed}
    \centering
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s \forall x \phi(x)$}
        \RightLabel{$[\forall]$}
        \UnaryInfC{$ @_c \phi(t)$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$\neg @_s \exists x \phi(x)$}
        \RightLabel{$[\neg \exists]$}
        \UnaryInfC{$\neg @_c \phi(t)$} 
      \end{prooftree}
    \end{multicols}
    \caption{Universal rules}
    \label{univ}
  \end{framed}
\end{figure*}

In the universal rules \ref{univ} $t$ is a grounded term on the branch
which exists at $D_s$.  

%% \begin{figure*}[!hbt]
\begin{figure*}[H]
  \begin{framed}
    \centering
  \begin{multicols}{3}
    \begin{prooftree}
      \AxiomC{}
      \RightLabel{$[=\textsf{--Ref}]$}
      \UnaryInfC{$t = t$} 
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$@_n m$}
      \RightLabel{$[\textsf{DD}]$}
      \UnaryInfC{$@_n q = @_m q$}
    \end{prooftree}
    
    \begin{prooftree}
      \AxiomC{$@_s t = u$}
      \AxiomC{$@_s \phi(t)$}
      \RightLabel{$[\textsf{RR}]$}
      \BinaryInfC{$@_s \phi[u]$} 
    \end{prooftree}
  \end{multicols}
  \caption{{\it QHTL} Equality rules}
\end{framed}
\end{figure*}


\subsection{Soundness}
The proof of the soundness of the tableau method
for {\it QHTL} is adapted from the proof of
soundness of the tableau method for
$\mathcal{H}(@)$ given in \citet*{internalizing}.

\bigskip

We can observe from the tableau rules that
every formula in a tableau is of the
form  $@_s \phi$ or $\neg @_s \phi$.
We call formulae of these forms
{\it satisfaction statements}.
Give a set of satisfaction statements $\Sigma$
and a tableau rule $R$ we develop the
notion of $\Sigma^+$ as an expansion of $\Sigma$
by $R$ as follows based on the different cases for $R$:
\begin{enumerate}
\item

  If $R$ is {\it not} a branching rule, and $R$ takes
  a single formula as input, and $\Sigma^+$ is the set
  obtained by adding to $\Sigma$ the formulae yielded
  by applying $R$ to $\sigma \in \Sigma$,
  then we say $\Sigma^+$ is the result of expanding
  $\Sigma$ by $R$.  
\item

  If $R$ is a binary rule, and $\Sigma^+$ is the set
  obtained by adding to $\Sigma$ the formulae yielded
  by applying $R$ to $\sigma_1 , \sigma_2  , \sigma_2 \in \Sigma$,
  then we say $\Sigma^+$ is the result of expanding
  $\Sigma$ by $R$.
\item

  If $R$ is a branching rule, and $\Sigma^+$ is the set
  obtained by adding to $\Sigma$ the formulae yielded
  by one of the possible outcomes of applying $R$ to $\sigma_1  \in \Sigma$,
  then we say $\Sigma^+$ is the result of expanding
  $\Sigma$ by $R$.
\item

  If a nominal $s$ belongs to some formula in $\Sigma$,
  then $\Sigma^+ = \Sigma \cup \{ @_s s \}$ is
  the result of expanding $\Sigma$ by \textsf{Ref}.
\item
  
  If a nominal $s$ belongs to some formula in $\Sigma$,
  then $\Sigma^+ = \Sigma \cup \{ @_s t = t \}$ is
  the result of expanding $\Sigma$ by $=$-\textsf{Ref}.

\end{enumerate}


\begin{definition}[Satisfiable by label]

  Suppose $\Sigma$ is a set of satisfaction statements and
  $\mathfrak{M} = (T, R, D_t, I_{nom}, I_t)_{t \in T}$
  is a standard {\it QHTL} model.
  We say $\Sigma$ is
  {\it satisfied by label} in $\mathfrak{M}$
  under a {\it QHTL} assignment $g$
  if and and only if for all formulae in $\Sigma$:
  \begin{enumerate}
  \item
    If $@_s \phi \in \Sigma$ then
    $\mathfrak{M}, g, I_{nom}(s) \dststile{}{} \phi$
  \item
    If $\neg @_s \phi \in \Sigma$ then
    $\mathfrak{M}, g, I_{nom}(s) \not \dststile{}{} \phi$
    
  \end{enumerate}

  We say $\Sigma$ is {\it satisfiable by label}
  if and only if there is a standard {\it QHTL} model
  and assignment in which it is satisfied by label.

  
\end{definition}

\begin{theorem}[{\bf Soundness}]
  \label{sound}
  If $\Sigma$ is a set of satisfaction
  statements which is satisfiable by label,
  then for any tableau rule $R$, at least one of the
  sets obtainable by expanding $\Sigma$ by $R$
  is satisfiable by label.  
\end{theorem}


%%\begin{proof}
({\it Proof})  We prove soundness by induction on the
tableau rules, with particular
attention to rules which introduce nominals new
to the branch, namely $\{ F, P, \neg G, \neg H \}$ \ref{fnp},
and rules which introduce new parameters to the branch,
namely the universal rules \ref{univ} and existential rules \ref{ext}.
In all cases discussed below let 
$$\mathfrak{M} = (T, R, D_t, I_{nom}, I_t)_{t \in T}$$
be {\it QHTL} model and $g$ the assignment
in which $\Sigma$ is satisfiable by label.

\begin{itemize}
\item {\it Non-branching Rules}

  We will take the $\land$ rule
  as an example.  Beginning
  from $@_s \phi \land \psi$ we have:
  $$\mathfrak{M}, g, I_{nom}(s) \dststile{}{} \phi \land \psi$$
  and consequentially 
  $$\mathfrak{M}, g, I_{nom}(s) \dststile{}{} \phi \iff @_s \phi$$
  $$\mathfrak{M}, g, I_{nom}(s) \dststile{}{} \psi \iff @_s \psi$$
  Similarly for their negations if at least one of $@_s \phi \land \psi$
  are not satisfied in $\mathfrak{M}$ under $g$.  
  Thus the results of the application of the $\land$ rule, $@_s \phi$ and $@_s \psi$
  are satisfiable in $\mathfrak{M}$ under $g$ and the expansion of $\Sigma$
  by $\land$ is satisfiable by label.
  \bigskip
  The proofs for other non-branching rules are analogous.
\item {\it Binary Rules}
  We will take the $H$ rule
  as an example.  Beginning
  with $@_s H \phi$ and $@_s P t$ we have from the former:
  $$\mathfrak{M}, g, t \dststile{}{} \phi \text{ for all } t \in T \text{ such that } R t I_{nom}(s)$$
  and from the latter:
  $$\mathfrak{M}, g, t' \dststile{}{} t \text{ for some } t' \in T \text{ such that } R t I_{nom}(s)$$
 
  and consequentially since $Rts$ 
  $$\mathfrak{M}, g, I_{nom}(t) \dststile{}{} \phi \iff @_t \phi$$
  Similarly for their negations if at least one of $@_s H \phi$ and $@_s P t$
  are not satisfied in $\mathfrak{M}$ under $g$.
  Thus the result of application of the $H$ rule, $@_t \phi$ is
  satisfiable in $\mathfrak{M}$ under $g$ and the expansion of $\Sigma$
  by $H$ is satisfiable by label.
  \bigskip
  The proofs for other binary rules is analogous.
\item {\it Branching Rules}
  We will take the $\lor$ rule
  as an example.  Beginning
  from $@_s \phi \lor \psi$ if it's satisfied we have:
  $$\mathfrak{M}, g, I_{nom}(s) \dststile{}{} \phi \lor \psi$$
  and consequentially at least one of 
  $$\mathfrak{M}, g, I_{nom}(s) \dststile{}{} \phi \iff @_s \phi$$
  or 
  $$\mathfrak{M}, g, I_{nom}(s) \dststile{}{} \psi \iff @_s \psi$$
  Similarly for their negations if $@_s \phi \lor \psi$ is not satisfied
  in $\mathfrak{M}$ under $g$.
  Thus at least one of the results of the application of the $\lor$ rule,
  $@_s \phi$ or $@_s \psi$ or their negations
  are satisfiable in $\mathfrak{M}$ under $g$ and the expansion of $\Sigma$
  by $\lor$ is satisfiable by label.
  \bigskip
  The proofs for other branching rules are analogous.
\item {\it Existential and Universal Rules}
  We will take the $\forall$ rule
  as an example.  Beginning
  from $@_s \forall x \phi (x)$ if it's satisfied we have
  (where $s' = I_{nom}(s)$):
  $$\mathfrak{M}, g', s' \dststile{}{} \phi \text{ for every } x\text{-variant of } g \text{ at } s$$
  That is for every $c$ in $D_{I_{nom}(s)}$, $\phi[t / x]$ is satisfied in $\mathfrak{M}$
  under $g$, similarly for $\neg \phi[t / x]$
  if $@_s \forall x \phi (x)$ is not satisfied
  in $\mathfrak{M}$ under $g$.  
  In accordance with the constraints for the rule we can select $t$ to be any
  grounded term on the branch which is also a member of $D_{I_{nom}(s)}$
  Thus the result of the application of the $\forall$ rule,
  or its negations
  are satisfiable in $\mathfrak{M}$ under $g$ and the expansion of $\Sigma$
  by $\forall$ is satisfiable by label.
  \bigskip
  The proofs for $\exists$, $\neg \exists$, and $\neg \forall$ are analogous.

\item {\it Rules Introducing a Nominal to the Branch}

  We will take the $F$ rule as am example.
  Beginning from $@_s F \phi$, if it's satisfied
  we have:
  $$\mathfrak{M}, g, I_{nom}(s) \dststile{}{} \phi \text{ for some } t \in T \text{ such that } R I_{nom}(s) t$$
  Let $a$ denote a nominal such that $R I_{nom}(s) I_{nom}(a)$ as above. As a result we have:
  $$\mathfrak{M}, g, I_{nom}(s) \dststile{}{} a \iff$$
  $$\mathfrak{M}, g, t \dststile{}{} a  \text{ for some } t \in T \text{ such that } R I_{nom}(s) t \iff$$
  $$\mathfrak{M}, g, I_{nom}(s) = Fa \iff @_s F a$$
  and
  $$\mathfrak{M}, g, I_{nom}(a) \dststile{}{} \phi \iff @_a \phi$$
  Similarly for their negations if $@_s F \phi$ is not satisfied in
  $\mathfrak{M}$ under $g$.
  
\item {\it Ref rules}
  $t = t$ is a tautology, invariant of model or assignment.
  For $@_s s$, we begin with having $s$ is the branch,
  as result we certainly have
  $$\mathfrak{M}, g, I_{nom}(s) \dststile{}{} I_{nom}(s) \iff @_s s$$
  Thus the expansion of $\Sigma$ by $=-$\textsf{Ref} or \textsf{Ref}
  is satisfiable by label.

  Using this we have demonstrated that the results of applicatition of a tableau rule to one or more premises
  reflect the validity or non-validity of the premises. \qed

\end{itemize}


\begin{figure*}[hbt!]
  \centering
  \begin{alignat*}{2}
    & AT_x (p) && := Px \\
    & AT_x (n) && := x = n \\
    & AT_x (w) && := x = w \\
    & AT_x (\neg \phi) && := \langle \lambda x . \neg AT_x (\phi) \rangle (x) \\
    & AT_x (\phi \land \psi) && := \langle \lambda x . AT_x (\phi) \land AT_x (\psi) \rangle (x) \\
    & AT_x(G \phi) && := \langle \lambda x . \forall y (Rxy \to AT_y (\phi)) \rangle (x) \\  
    & AT_x(H \phi) && := \langle \lambda x . \forall y (Ryx \to AT_y (\phi)) \rangle (x) \\
    & AT_x(@_n \phi) && := \langle \lambda x . \forall x (x = n \to AT_x (\phi)) \rangle (x) \\
    & AT_x(P(t_1, \dotsc, t_k)) && := P'(x, t_1, \dotsc, t_k) \\
    & AT_x(t_i = t_j) && := \langle \lambda x . t_i = t_j \rangle(x) \\
    & AT_x (\forall v \phi) && := \langle \lambda x . \forall v AT_x(\phi) \rangle (x)  
    %%\caption{$AT_x^-$}
  \end{alignat*}
  \caption{{\it QHTL} Formulae to First-order Formulae Translation.}
  \label{qhtl2fol}
\end{figure*}


\begin{figure*}[hbt!]
  \centering
  \begin{alignat*}{2}
    & AT_x^- (Px) && := p \\
    & AT_x^- (x = n) && := n \\
    & AT_x^- (x = w) && := w \\
    & AT_x^- (\langle \lambda x . \neg \phi \rangle (x)) && := \neg AT_x^- (\phi) \\
    & AT_x^- (\langle \lambda x . \neg \phi \land \psi \rangle (x)) && := AT_x^- (\phi) \land AT_x^- (\psi) \\
    & AT_x^-(\langle \lambda x . \forall y (Rxy \to \phi) \rangle (x)) && := G AT_y^- (\phi) \\  
    & AT_x^-(\langle \lambda x . \forall y (Ryx \to \phi) \rangle (x)) && := H AT_y^- (\phi) \\
    & AT_x^-(\langle \lambda x . \forall x (x = n \to \phi) \rangle (x)) && := @_n AT_x^- (\phi) \\
    & AT_x^-(P'(x, t_1, \dotsc, t_k)) && := P(t_1, \dotsc, t_k) \\
    & AT_x^-(\langle \lambda x . t_i = t_j \rangle(x)) && := t_i = t_j \\
    & AT_x^- (\langle \lambda x . \forall v  \phi \rangle (x)) && := \forall v AT_x^- (\phi)   
    %%\caption{$AT_x^-^-$}
  \end{alignat*}
  \caption{First-order Formulae to {\it QHTL} Formulae Translation.}
  \label{fol2qhtl}
\end{figure*}

\begin{figure*}[hbt!]
  \centering
  \begin{alignat*}{2}
    & P(t)^* && := @_t p \\
    & (t = u)^* && := @_t u \\
    & (Rst)^* && := @_s F t \\
    & (\langle \lambda x.\phi \rangle (t))^* && := @_t AT_x^- (\langle \lambda x . \phi \rangle (x))\\  
    & (\langle \lambda y.\phi \rangle (t))^* && := @_t AT_y^- (\langle \lambda y . \phi \rangle (y))\\
    & (AT_x(\phi)[t / x])^* && := @_t \phi \\
    & (\neg AT_x(\phi)[t / x])^* && := \neg @_t \phi \\
    & P'(s, t_1, \dotsc, t_k)^* && := @_s P(t_1, \dotsc, t_k) \\
    & (t_i = t_j)^* && := t_i  t_j 
    %% \caption{$AT_x^-^-$}
  \end{alignat*}
  \caption{Translation of First-order Tableau Literals to {\it QHTL} Literals.}
  \label{literal}
\end{figure*}


\subsection{Decidability}

The proof of the tableau construction algorithm's termination is adapted from
the proof given in \citet*{bolander} for the termination of the
tableau construction algorithm for $\mathcal{H}(@)$
as described in \citet*{internalizing} except extended with the universal modality.

\begin{definition}
  When a formula $@_s \phi$ occurs in a tableau
  branch $\Theta$ we will write $@_s \phi \in \Theta$,
  and say $\phi$ is true at $s$ on $\Theta$ or
  $s$ makes $\phi$ true on $\Theta$.  
\end{definition}

\begin{definition}
  Given a tableau branch $\Theta$ and a nominal or state variable
  $s$ the {\it set of true formulae} at $s$ on $\Theta$,
  is written $T^\Theta (s)$ and defined as follows:
  $$T^\Theta (s) = \{ \phi \mid @_s \phi \in \Theta \}$$
\end{definition}

\begin{definition}
  A formula $\phi$ is a {\it quasi-subformula } of a
  formula $\psi$ if one of the the following is the case:
  \begin{enumerate}
  \item
    $\phi$ is a subformula of $\psi$.
  \item
    $\phi$ is of the form $\neg \chi$ where $\chi$
    is a subformula $\psi$
  \end{enumerate}
\end{definition}

\begin{lemma}[{\bf Quasi-subformula Property}]
  Let $\mathcal{T}$ be a tableau with the formula
  $@_s \phi$ as root.
  For any formula $@_t \psi$ occuring on $\mathcal{T}$,
  $\psi$ is a quasi-subformula of $\phi$.
\end{lemma}


({\it Proof}) This is verified by induction on the tableau rules.


\begin{definition}
\end{definition}

\begin{theorem}
\end{theorem}

\begin{corollary}
\end{corollary}

\begin{definition}
\end{definition}

\begin{theorem}
\end{theorem}

\begin{definition}
\end{definition}

\begin{prop}
\end{prop}

\begin{definition}
\end{definition}

\begin{definition}
\end{definition}

\begin{theorem}
\end{theorem}



\section{AMR Interpretation in Hybrid Logic}

\subsection{Examples}

\enumsentence{
  a. Carl submitted the forms and everyone will sign up again tomorrow.
  \\
  b.
  \\
  \scriptsize\texttt{(a / and\\
    \hspace*{0.5cm}:op1 (s / scope\\
    \hspace*{1.0cm}:pred (f / fill-out-03 :ongoing - :complete + :time (b / before :op1 (n / now))\\
    \hspace*{1.5cm}:ARG0 (p / person\\
    \hspace*{2.0cm}:name (n2 / name\\
    \hspace*{2.5cm}:op "Carl"))\\
    \hspace*{1.5cm}:ARG1 (f2 / form))\\
    \hspace*{1.0cm}:ARG0 p\\
    \hspace*{1.0cm}:ARG1 f2)\\
    \hspace*{0.5cm}:op2 (s2 / scope\\
    \hspace*{1.0cm}:pred (m / submit-01  :ongoing - :complete + :time (a2 / after :op1 n)\\
    \hspace*{1.5cm}:ARG0 (p2 / person\\
    \hspace*{2.0cm}:mod (a3 / all))\\
    \hspace*{1.5cm}:ARG1 f2)\\
    \hspace*{1.0cm}:ARG0 p2\\
    \hspace*{1.0cm}:ARG1 f2))}
  \\
c. It was impossible not to notice the car.
\\
d.
\\
\small\texttt{(s / scope\\
  \hspace*{1.0cm}:pred (p / possible-01\\
  \hspace*{1.5cm}:ARG0 (n / notice-01  :ongoing - :complete + :time (b / before :op1 (n2 / now))\\
  \hspace*{2.0cm}:polarity (n3 / not)\\
  \hspace*{2.0cm}:ARG1 (c /car)\\
  \hspace*{1.5cm}:polarity (n4 / not))\\
  \hspace*{1.0cm}:ARG0 n4\\
  \hspace*{1.0cm}:ARG1 p))}
}
\smallskip
NB: Will complete these translations in full.
\subsection{Extraction Steps}
With the chosen annotation, the root node
can consist of either a logical connective
(\verb|and|, \verb|or|, or \verb|cond|) linking two
AMR graphs, or a \verb|scope| node with its following
predicate and arguments.      

\subsection{General Extraction Algorithm}

\section{Future Work}

\subsection{$\downarrow$ and Quantification over Nominals}
Main points, at the cost of undecidability with adding $\downarrow$
some additional things can be done,
and at the cost of the integration of generalized quantifiers you can
ostensibly handle even things like habitual aspect.

\subsection{AMR Reentrancy and Non-Temoral Nominals}


There are some difficulties with maintaining the usual notion of possible
worlds being maximal with this idea, but there seems to be a direct sympathy between
the predicative core of an AMR sentence and in general reentrancy of the nodes with the
idea of a nominal as a ``point of view'' rather than the ``name'' of a world.
Maybe things like epistemic logic could be helpful here.
\subsection{Automated Inference and HTab}

HTab \citep{htab} provides an implementation of $\mathcal{H}(@, \textsf{A})$,
which does not natively provide a way to reason with $P$, $H$,
or first-order quantification.  The effort required in making the needed
changes to handle these remains to be determined.
\subsection{The Future of AMR and Parsing for Semantic Features}

To what extent can current AMR parsers extract the needed semantic features
to make full use of automated inference?  Of UMR, Dialogue-AMR,
and the AMR annotation variants we've used,
which logistically has the best outlook?
\section{Conclusion}


\bibliographystyle{acl_natbib}
\bibliography{references}
\end{document}
