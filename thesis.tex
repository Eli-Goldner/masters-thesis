% 
% File acl2019.tex
%
%% Based on the style files for ACL 2018, NAACL 2018/19, which were
%% Based on the style files for ACL-2015, with some improvements
%%  taken from the NAACL-2016 style
%% Based on the style files for ACL-2014, which were, in turn,
%% based on ACL-2013, ACL-2012, ACL-2011, ACL-2010, ACL-IJCNLP-2009,
%% EACL-2009, IJCNLP-2008...
%% Based on the style files for EACL 2006 by 
%%e.agirre@ehu.es or Sergi.Balari@uab.es
%% and that of ACL 08 by Joakim Nivre and Noah Smith
\documentclass[9pt,a4paper]{article}
%\documentclass[9pt,halfline,a4paper]{ouparticle}
%\documentclass[9pt,a4paper]{ouparticle}
%%\usepackage[hyperref]{acl2021}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{times}
\usepackage{latexsym}
\usepackage{lingstyle}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{bussproofs}
\usepackage{multicol}
%%\usepackage{prftree.sty} 
\usepackage{natbib}
\usepackage{cite}
\usepackage{float}
%%\usepackage{stfloats}
%%\usepackage{turnstile}
\usepackage{rotating}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{framed}
\usepackage{mdframed}

\usepackage[ruled,vlined]{algorithm2e}

\usepackage[margin=1.0in]{geometry}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{corollary}{Corollary}


\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\DeclareMathSymbol{:}{\mathord}{operators}{"3A}
\renewcommand{\phi}{\varphi}
%%\newenvironment{proof}{\paragraph{Proof:}}{\hfill$\square$}

\usetikzlibrary{arrows,positioning,shapes} 
\tikzset{
    %Define standard arrow tip
    >=stealth',
    %Define style for boxes
    amrnode/.style={
             ellipse,
             draw=black, very thick,
             font=\small},
    scopenode/.style={
             ellipse,
             draw=red, very thick, dashed,
             text=red,
             font=\small},
    % Define arrow style
    amrarrow/.style={
            ->,
            thick,
            font=\small},
    scopearrow/.style={
              ->,
              red,
              thick,
              dashed,
              font=\small}
}

 \def\drs#1#2{\begin{tabular}{|l|}\hline #1 \\ \hline \\
                [-8pt] #2\\[-8pt] \\ \hline \end{tabular} }

 \def\ddrs#1{\begin{tabular}{||c||}\hline \\
                [-8pt] #1\\[-8pt] \\ \hline \end{tabular} }

 \def\topdrs#1#2{\begin{tabular}{|l|}\hline #1 \\ \hline \\
                [-8pt] #2 \\[-8pt] \\ \hline \end{tabular} }

 %%\def\proof#1#2#3#4{\drs{#1}{#2} \ $\vdash$ \ \drs{#3}{#4}}
 \def\modimp#1#2#3#4{\mbox{\drs{#1}{#2} \ $\Box$ \ \drs{#3}{#4}}}
 \def\imp#1#2#3#4{\drs{#1}{#2} \ $\Rightarrow$ \ \drs{#3}{#4}}
 \def\dis#1#2#3#4{\mbox{\drs{#1}{#2} \ $\vee$ \ \drs{#3}{#4}}}
 \def\int#1#2{\mbox{$^{\wedge}$ \ \drs{#1}{#2}}}
 %%\def\pos#1#2{\mbox{$\lozenge$ \ \drs{#1}{#2}}}
 %%\def\nec#1#2{\mbox{$\Box$ \ \drs{#1}{#2}}}
 \def\nega#1#2{\mbox{$\neg$ \ \drs{#1}{#2}}}
 \def\pred#1#2#3{\mbox{#1\ :\drs{#2}{#3}}}


\usepackage{url} 

\usepackage[acronym]{glossaries} % 'nomain' to disable automatic generation of "glossary" section 
\glsdisablehyper % disable hyperlink to non-existing glossary section 
%\aclfinalcopy % Uncomment this line for the final submission
%\def\aclpaperid{***} %  Enter the acl Paper ID here

%\setlength\titlebox{5cm}
% You can expand the titlebox if you need extra space
% to show all the authors. Please do not make the titlebox
% smaller than 5cm (the original size); we will check this
% in the camera-ready version and ask you to change it back.

\newcommand\BibTeX{B\textsc{ib}\TeX}

\makeatletter
\newcommand\footnoteref[1]{\protected@xdef\@thefnmark{\ref{#1}}\@footnotemark}
\makeatother


\title{Formalization of AMR Inference via Hybrid Logic Tableaux}
 

 
\author{
  Eli Goldner
}
\begin{document}
\maketitle
\begin{abstract}
  AMR and its extensions have become popular in semantic representation due
  to their ease of annotation by non-experts, attention to the predicative core of sentences,
  and abstraction away from various syntactic matter.
  An area where AMR and its extensions warrant improvement is formalization
  and suitability for inference, where it is lacking compared to
  other semantic representations, such as
  description logics, episodic logic, and discourse representation theory.
  This thesis presents a formalization of inference over a merging of
  \citeauthor{donatelli-etal-2018-annotation}'s \citeyearpar{donatelli-etal-2018-annotation} AMR extension for tense and aspect
  and with \citeauthor{pustejovsky-etal-2019-modeling}'s \citeyearpar{pustejovsky-etal-2019-modeling} AMR extension for quantification and scope.
  Inference is modeled with a merging of \citeauthor{hansen2007tableau}'s
  \citeyearpar{hansen2007tableau} tableau method for
  first-order hybrid logic with varying domain semantics 
  ({\it FHL}) and \citeauthor{blackburn2012indexical}'s \citeyearpar{blackburn2012indexical}
  tableau method for basic hybrid tense logic ({\it BHTL}).
  We motivate the merging of these AMR variants,
  present their interpretation and inference in the combination of {\it FHL}
  and {\it BHTL}, which we will call {\it FHTL} (first-order hybrid tense logic),
  and demonstrate {\it FHTL}'s soundness, completeness,
  and decidability.   
\end{abstract}


\section{Introduction}

\section{Related Work}


\subsection{Semantic Features in AMR and Possbility of Inference}

%% Reference UMR?

Separating argument structure in AMR from logical structure, enables
translation from AMR to DRT \citep{bos-2020-separating}

AMR expressivity without recurrent variables
(and with no more than one universal quantifier per sentence)
are in the decidable two-variable fragment of first-order logic \citep{bos-2016-squib}

Extension of sentential AMR to incorporate a coarse grained
treatment of tense and aspect \citep{donatelli-etal-2018-annotation}

Continuation based semantics for translating AMR into first-order
logic in a way that preserves projection phenomena such as quantification,
negation, bound variables, and donkey anaphora, which better affords
inference than other first-order logic semantics for AMR \citep{lai-etal-2020-continuation}.
This uses a neo-davidsonian representation for the target first-order logic semantics.  

\section{Merging Quantified Hybrid Logic and Indexical Hybrid Tense Logic}

\subsection{Background}

Hybrid logic is an extension of the propositional modal logic $K$
($K$ has no conditions on the modal frame of its underlying models)
allowing for explicit reference to modal states/worlds through a prefix notation.
Where ordinary modal logic writes $\lozenge p$ to indicate that there is some
world where $p$ holds at some world accessible from that world,
hybrid logic by default writes one of
$a \lozenge p$, $a :\lozenge p$, or $@_a \lozenge p$
(we use the latter notation from here on),
to indicate $p$ holds at some world accessible
from $a$ specifically.
$a$ in this notation is a {\it nominal},
which uniquely names a world in the underlying model.
A {\it world} in a modal or hybrid model for us
is essentially just a maximal set of sentences in the language,
that is for any proposition $p$ and nominal $a$ we have either
$@_a p$ or $@_a \neg p$.  Worlds are used to model any notion
consistent with it, usually possible states of affairs,
in particular we will use them to describe states of affairs at
different points in time.  

\subsection{First-order Hybrid Logic}

First-order modal logic (or quantified modal logic / QML) extends first-order predicate logic
in a way analogous to how propositional modal logic extends first order
propositional logic.
An introduction to both QML and propositional modal logic can be found in
\citet*{fitting-modal}. 
\citet*{hansen2007tableau}

from 

\citet*{quantified}

\subsection{Basic Hybrid Tense Logic}

\citet*{blackburn2012indexical}

\section{First-order Hybrid Tense Logic - Syntax and Semantics}
\smallskip
The syntax of {\it FHTL} is identical to {\it FHL} as given in \citet*{hansen2007tableau} except
uses of $\downarrow$ as in $\downarrow w . \phi$ are omitted along
with $\Box$ and $\lozenge$ as in $\Box \phi$ and $\lozenge \phi$.
$\Box$ and $\lozenge$ are replaced by their semantic equivalents
$F$ and $G$ and their temporal duals $P$ and $H$ are added.

\smallskip


Atomic formulae are the same as in {\it FHL}, symbols in \textsf{NOM}
and \textsf{SVAR} together with first-order atomic formulae
generated from the predicate symbols and equality over the terms. 
Thus complex formulae are generated from the atomic formulae according to the
following rules:
$$\neg \phi \mid \phi \land \psi \mid \phi \lor \psi \mid \phi \to \psi \mid \exists x \phi \mid \forall x \phi \mid F \phi \mid G \phi \mid P \phi \mid H \phi \mid @_n \phi $$



Since we want the domain of quantification to be indexed
over the collection of nominals/times, we look to
\citeauthor{fitting-modal}'s \citeyearpar{fitting-modal}
treatment of first-order modal logic with varying domain semantics
and use it to alter the {\it FHL} model definition
to the following:
$$(T, R, D_t, I_{nom}, I_t)_{t \in T}$$
Thus with varying domain semantics a {\it FHTL}
model is identical to the definition for a {\it FHL} model in that:
\begin{itemize}
  \item
    $(T,R)$ is a modal frame.
  \item
    $I_{nom}$ is a function assigning members of $T$ to nominals.
\end{itemize}

The differences manifest on the level of the model and
interpretation.  Namely, where $D = \cup_{t \in T} D_t$,
$(D, I_t)$ is a first-order model where:
\begin{itemize}
\item
  $I_t (q) \in D$ where $q$ is a unary function symbol.
\item
  $I_t (P) \in D^k$ where $P$ is a $k$-ary predicate symbol.
\end{itemize}

Notice we've relaxed the requirement that $I_t (c) = I_{t'} (c)$ for
$c$ a constant and $t,t' \in T$, since the interpretation of the
constant need not exist at both times.  This permits us to distinguish
between the domain of a frame and the domain of a time/world,
in a way that prevents a variable $x$ from failing to refer
at a given time/world, even if it has no interpretation at that time.
Intuitively this permits {\it FHTL} to handle interpretation of entities
in natural language utterances, which while reasonable to refer to
do not exist at a current time, e.g. previous and future presidents.


\smallskip

Free variables are handled similarly as in {\it FHL}.
Where again $D = \cup_{t \in T} D_t $, a {\it FHTL} assignment is a function:
$$g : \textsf{SVAR} \cup \textsf{FVAR} \to T \cup D $$
Where state variables are sent to times/worlds and
first-order variables are sent to $D$, the domain
of the frame.
Thus given a model and an assignment $g$,
the interpretation of terms $t$ denoted by $\overline{t}$
is defined as:
\begin{itemize}
\item
  $\overline{x} = g(x)$ for $x$ a variable.
\item
  $\overline{c} = I_t (c)$ for $c$ a constant and some $t \in T$.
\item For $q$ a unary function symbol:
  \begin{itemize} 
  \item
    For $n$ a nominal:
    $$\overline{@_n q} = I_{I_{nom}(n)} (q)$$
  \item
    For $n$ a state variable:
    $$\overline{@_n q} = I_{g(n)} (q)$$
  \end{itemize}
\end{itemize}

Finally we say an assignment $g'$ is an $x$-variant of $g$ if $g'$
and $g$ on all variables except possiblly $x$.
In particular, we say $g'$ is an $x$-variant of $g$ at $t$, a time, if $g'$
and $g$ on all variables except possiblly $x$ and $g'(x) \in D_t$.
We omit definitions for $\land$, $\to$, $H$, $G$, and $\forall$, since
they can be defined in terms of the other rules.
Given a model $\mathfrak{M}$, a variable assignment $g$,
and a state $s$, the inductive definition of
$\mathfrak{M}, s \vDash_g \phi$ is:

\begin{alignat*}{2}
  &\mathfrak{M}, s \vDash_g P(t_1, \dotsc , t_n )  && \Longleftrightarrow \langle \overline{t_1}, \dotsc , \overline{t_n} \rangle \in I_s (P)  \\
  &\mathfrak{M},  s \vDash_g t_i = t_j  && \Longleftrightarrow \overline{t_i} = \overline{t_j}  \\
  &\mathfrak{M},  s \vDash_g n && \Longleftrightarrow I_{nom} (n) = s, \text{for }n\text{ a nominal}  \\
  & \mathfrak{M},  s \vDash_g w && \Longleftrightarrow g(w) = s, \text{for }w\text{ a state variable}  \\
  & \mathfrak{M},  s \vDash_g \neg \phi && \Longleftrightarrow  \mathfrak{M},  s \not\vDash_g \phi \\
  & \mathfrak{M},  s \vDash_g \phi \lor \psi && \Longleftrightarrow  \mathfrak{M},  s \vDash_g \phi \text{ or } \mathfrak{M},  s \vDash_g \psi \\
  & \mathfrak{M},  s \vDash_g \exists x \phi && \Longleftrightarrow \mathfrak{M}, s \vDash_{g'} \phi \text{ for some } x\text{-variant }g'\text{ of } g \text{ at } s \\
  & \mathfrak{M},  s \vDash_g F \phi && \Longleftrightarrow \mathfrak{M},  t \vDash_g \phi \text{ for some } t \in T \text{ such that } Rst \\
  & \mathfrak{M},  s \vDash_g P \phi && \Longleftrightarrow \mathfrak{M},  t \vDash_g \phi \text{ for some } t \in T \text{ such that } Rts \\
  & \mathfrak{M},  s \vDash_g @_n \phi && \Longleftrightarrow \mathfrak{M},  I_{nom}(n) \vDash_g \phi \text{ for } n \text{ a nominal } \\
  & \mathfrak{M},  s \vDash_g @_w \phi && \Longleftrightarrow \mathfrak{M},  g(w) \vDash_g \phi \text{ for } w \text{ a state variable }
  %%\caption{$AT_x$}
\end{alignat*}

\subsection{The Tableau Calculus}


\iffalse

\begin{prooftree}
  \AxiomC{$@_t s$}
  \RightLabel{$[\textsf{Sym}]$}
  \UnaryInfC{$@_s t$}
\end{prooftree}

\fi

Following \citet*{fitting-modal} we assume for each nominal
or state variable $s$,
there is an infinite list of parameters, where parameters are free variables
which are never quantified over, arranged in such a way that different
nominals/state variables
never share the same parameter.  Informally we write $p_s$ to indicate
a parameter is associated with a nominal/state variable $s$.  

%%\begin{adjustbox}{max size={\textwidth}{\textheight}, nofloat = figure}
\begin{figure*}[!h]
  \centering
  \begin{adjustbox}{varwidth=1.1\linewidth,scale=0.85}
    %% \begin{framed}
    \centering
    \begin{mdframed}
    \centering

    \underline{\bf Propositional rules:}
    
    \begin{multicols}{3}
      \begin{prooftree}
        \AxiomC{$@_s (\phi \lor \psi)$}
        \RightLabel{\bf ($\lor$)}
        \UnaryInfC{$@_s \phi \mid @_s \psi$} 
      \end{prooftree}
      
      
      \begin{prooftree}
        \AxiomC{$@_s \neg (\phi \lor \psi)$}
        \RightLabel{\bf ($\neg \lor$)}
        \UnaryInfC{$@_s \neg \phi$}
        \noLine
        \UnaryInfC{$@_s \neg \psi$}
      \end{prooftree}
      
      
      \begin{prooftree}
        \AxiomC{$ @_s \neg \neg \phi$}
        \RightLabel{\bf ($\neg \neg$)}
        \UnaryInfC{$@_s \phi$}
      \end{prooftree}
      
    \end{multicols}

    \underline{\bf Modal rules:}

    %% \begin{multicols}{2}
    \begin{multicols}{4}
      \begin{prooftree}
        \AxiomC{$@_s F \phi$}
        \RightLabel{\bf ($F$)\footnote{\label{intro}The nominal $a$ is new to the branch.}\footnote{\label{nom}The formula $\phi$ is not a nominal.}}
        \UnaryInfC{$@_s F a$}
        \noLine
        \UnaryInfC{$@_a \phi$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s P \phi$}
        \RightLabel{\bf ($P$)\footnoteref{intro}\footnoteref{nom}}
        \UnaryInfC{$@_s P a$}
        \noLine
        \UnaryInfC{$@_a \phi$}
      \end{prooftree}
      
    %%\end{multicols}
  
    
    %%\begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s \neg P \phi$}
        \AxiomC{$@_s P t$}
        \RightLabel{\bf ($\neg P$)}
        \BinaryInfC{$@_t \neg \phi$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s \neg F \phi$}
        \AxiomC{$@_s F t$}
        \RightLabel{\bf ($\neg F$)}
        \BinaryInfC{$@_t \neg \phi$}
      \end{prooftree}
    \end{multicols}

    
    \underline{\bf Quantifier rules:}
    
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s \exists x \phi$}
        \RightLabel{\bf ($\exists$)\footnote{$s : p$ is new to the branch.}}
        \UnaryInfC{$@_s \phi[s:p / x]$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s \neg \exists x \phi$}
        \RightLabel{\bf ($\neg \exists$)\footnote{$p$ is any ground term or parameter which exists at $s$.}}
        \UnaryInfC{$@_s \neg \phi[t / x]$} 
      \end{prooftree}
    \end{multicols}
    
    \underline{\bf Equality rules:}


    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{}
        \RightLabel{\bf (ref)\footnote{\label{closed}Where $t$ is a closed term.}}
        \UnaryInfC{$@_i j:t = j:t$} 
      \end{prooftree}
      
      
      \begin{prooftree}
        \AxiomC{$@_i j:t = k:s$}
        \AxiomC{$@_i \phi$}
        \RightLabel{\bf (sub)\footnote{\label{subst}$\phi[j:t // k:s]$ is $\phi$ where some occurences of $j:t$ have been replaced by $k:s$.}}
        \BinaryInfC{$@_i \phi[j:t // k:s]$} 
      \end{prooftree}
    \end{multicols}

    \underline{\bf @ rules:}
    
    \begin{multicols}{2}
    %\begin{multicols}{4}
      \begin{prooftree}
        \AxiomC{$@_s @_t \phi$}
        \RightLabel{\bf ($@$)}
        \UnaryInfC{$@_t \phi$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s \neg @_t \phi$}
        \RightLabel{\bf ($\neg @$)}
        \UnaryInfC{$@_t \neg \phi$} 
      \end{prooftree}
      
    \end{multicols}
    
    
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s t$}
        \AxiomC{$@_s \phi$}
        \RightLabel{\bf (nom)}
        \BinaryInfC{$@_t \phi$} 
      \end{prooftree}
      
      \begin{prooftree}
        % \AxiomC{$[i\text{ on the branch}]$}
        \AxiomC{[$i$ on the branch]}
        \RightLabel{\bf (nom ref)}
        \UnaryInfC{$@_i i$} 
      \end{prooftree}
      
    \end{multicols}
    
    \begin{multicols}{2}
    %\begin{multicols}{4}
      \begin{prooftree}
        \AxiomC{$@_s P t$}
        \RightLabel{\bf ($P\textbf{--trans}$)}
        \UnaryInfC{$@_t F s$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s F t$}
        \RightLabel{\bf ($F\textbf{--trans}$)}
        \UnaryInfC{$@_t P s$}  
      \end{prooftree}
    \end{multicols}
    
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s P t$}
        \AxiomC{$@_t u$}
        \RightLabel{\bf ($P\textbf{--bridge}$)}
        \BinaryInfC{$@_s P u$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s F t$}
        \AxiomC{$@_t u$}
        \RightLabel{\bf ($F\textbf{--bridge}$)}
        \BinaryInfC{$@_s F u$}  
      \end{prooftree}
    \end{multicols}
    
    \underline{\bf {\it FHTL} term rules:}
    
    \begin{multicols}{3}
      \begin{prooftree}
        \AxiomC{$@_i k_1 : t = k_2 : s$}
        \RightLabel{\bf (:1)}
        \UnaryInfC{$@_i k_1 : t = k_2 : s$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_i j$}
        \RightLabel{\bf (:2)\footnoteref{closed}}
        \UnaryInfC{$@_k i: t = j : t$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{}
        \RightLabel{\bf (:3)\footnoteref{closed}}
        \UnaryInfC{$@_i k :j: t = j : t$}
      \end{prooftree}
    \end{multicols}

    %%\begin{multicols}{2}
    \begin{multicols}{4}
      \begin{prooftree}
        \AxiomC{$@_i R(t_1,...,t_n)$}
        \RightLabel{\bf (:fix 1)}
        \UnaryInfC{$@_i R(i:t_1,...,i:t_n)$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_i \neg R(t_1,...,t_n)$}
        \RightLabel{\bf (:fix 2)}
        \UnaryInfC{$@_i \neg R(i:t_1,...,i:t_n)$}
      \end{prooftree}
    %%\end{multicols}
    
    %%\begin{multicols}{2}  
      \begin{prooftree}
        \AxiomC{$@_i t = s$}
        \RightLabel{\bf (:fix 3)}
        \UnaryInfC{$@_i i : t = i : s$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_i \neg t = s$}
        \RightLabel{\bf (:fix 4)}
        \UnaryInfC{$@_i \neg i : t = i : s$}
      \end{prooftree}
    \end{multicols}
    
    \begin{prooftree}
      \AxiomC{}
      \RightLabel{\bf (:func)\footnote{$f$ is an $n$--ary function symbol and $t_1,...,t_n$ are closed terms.}}
      \UnaryInfC{$@_i f(t_1,..., t_n) = f(i:t_1,..., i:t_n)$}
    \end{prooftree}
    
  \end{mdframed}
\end{adjustbox}
\end{figure*}


\subsection{Soundness and completeness}

\begin{definition}[{\bf Quasi-subformula}]
  A formula $\phi$ is a {\it quasi-subformula } of a
  formula $\psi$ if one of the the following is the case:
  \begin{enumerate}
  \item
    $\phi$ is a subformula of $\psi$ modulo
     renaming of free variables and substitution
    of free variables in $\phi$ for grounded terms.
  \item
    $\phi$ is of the form $\neg \chi$ where $\chi$
    is a subformula of $\psi$ modulo renaming
    of free variables in $\chi$ for grounded terms.
  \end{enumerate}
  Altering the definition to allow grounded terms being substituted
  for free variables ensures compatibility of the following proofs
  with the quantifier and term rules.  We say a formula $@_s \phi$
  on a {\it FHTL} tableau branch $\Theta$ is a {\it root subformula}
  if $\phi$ is a quasi subformula of the root formula of the tableau.  
\end{definition}



\begin{lemma}[{\bf Subformula Property}]
  \label{subformula}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  and a formula $@_s \phi$ occurs on $\Theta$ where
  $\phi$ is not of the form $a$, $F a$, or $P a$ for $a$ a nominal,
  or $u = t$ for optionally prefixed closed terms $t$ and $u$,
  then $\phi$ is a root subformula. 
\end{lemma}

\begin{proof}
  This is verified by checking the tableau rules.
  \iffalse
  We observe the propositional, quantifier, and $@$ rules, along with
  {\bf (:fix 1)}, {\bf (:fix 2)}, and {\bf (:fix 4)} can only take
  root-subformulae as premises and yield root-subformulae as conclusions.
  Definitionally {\bf (ref)}, {\bf (:3)}, and {\bf (:func)}
  generate only term equality formulae
  and {\bf (nom  ref)} generates only nominal equality formulae.
  Whether the premise of {\bf (:2)} is a nominal equality or root-subformula,
  the conclusion is a term equality.  {\bf (:1)} and {\bf (:fix 3)} both preserve
  the ``type'' of their premise, since {\bf (:1)}'s conclusion only changes the nominal
  prefix and if {\bf (:fix 3)}'s premise is a root-subformula then its
  conclusion with its changed terms
  is still a quasi-subformula of the premise by definition.
  \bigskip
  This leaves us with {\bf ($F/P$}), {\bf ($\neg F / \neg P$)},
  {\bf ($F/P$--bridge)}, {\bf (sub)}, and {\bf (nom)}.
  The premise of {\bf ($F/P$}) must be either an accessibility formula or a root subformula,
  in the first case the second conclusion is a nominal equality,
  and in the second case the second conclusion is a root subformula,
  in either case the first conclusion is an accessibility formula.
  In the case of {\bf ($\neg F / \neg P$)}, the first premise can only be
  a root subformula since there's no way to introduce a negation,
  as a result the conclusion must be a root subformula.
  In the case of {\bf ($F/P$--bridge)}, the second premise is
  either an accessibility formula or a root subformula, and since
  the definition of quasi-subformula allows for substitution of (equivalent) nominals,
  the conclusion is the same kind of formula as the second premise.  
  Likewise {\bf (sub)}'s conclusion will be of the same type as its second premise
  since the definition of quasi-subformula allows for substitution of (equivalent) terms.  
  And finally {\bf (nom)}'s conclusion will be of the same type as its second premise
  since the definition of quasi-subformula allows for change of prefix nominals.
  \fi
\end{proof}

\begin{definition}[$\prec_{\Theta}$]
  \label{prec}
  Where $\Theta$ is a tableau branch in
  the {\it FHTL} calculus, if a nominal $a$
  is introduced to the branch by application of
  of $F$ or $P$
  to a premise $@_s \phi$, we
  say $a$ is {\it generated} by $s$
  on $\Theta$ and write $s \prec_{\Theta} a$.
  We write $\prec_{\Theta}^*$ to denote the reflexive and transitive
  closure of $\prec_{\Theta}$.  
\end{definition}

\begin{definition}[$N_{\Theta}$]
  The set of nominals and state variables which occur on $\Theta$
  is written $N_{\Theta}$
\end{definition}

\begin{lemma}
  \label{wellfounded}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  the graph $G = (N_{\Theta}, \prec_{\Theta})$ is
  a wellfounded finitely branching tree.
\end{lemma}

\begin{proof}
  Each aspect is proved below:
  \begin{itemize}
  \item {\it Wellfoundedness of trees in }$G$
    
    We have that if $a \prec_{\Theta} b$
    then the first occurence of $a$
    on $\Theta$ is before the first occurence
    of $b$, thus by induction any subset of $N_{\Theta}$ under the relation
    $\prec_{\Theta}$ has a least element and each tree in $G$ is wellfounded.
  \item $G$ {\it is a tree}
    
    Every nominal in $N_{\Theta}$
    can be generated by at most one other nominal, 
    and every nominal in $N_{\Theta}$
    must have one of the finitely many nominals in the
    root formula as an ancestor.
  \item $G$ {\it is finitely branching}
    
    We show $G$ is finitely branching by showing that
    given a nominal $a$, there can only be finitely
    many distinct nominals $b$ such that
    $a \prec_{\Theta} b$.
    Each nominal $b$
    such that
    $a \prec_{\Theta} b$
    is generated by applying one of 
    $F$, $P$ to
    a premise of the form
    $@_i F \phi$ or $@_i P \phi$
    respectively, where by
    our restrictions, either $\phi$
    is not a nominal, or the entire
    premise is a root subformula.
    Since there can only be finitely
    many root subformulae of the form
    of one of the the possible premises,
    where $i$ is the prefix nominal in each case,
    only finitely many new nominals have been generated
    from $i$.  Thus $G$ is finitely branching.
    
  \end{itemize}
\end{proof}

\begin{lemma}
  \label{inf}
  Where $\Theta$ is a tableau branch in the {\it FHTL} calculus,
  $\Theta$ is infinite if and only if there exists an infinite
  chain of nominals and state variables
  $a_1 \prec_{\Theta} a_2 \prec_{\Theta} \dotsc \prec_{\Theta} a_n \prec_{\Theta} \dotsc $
\end{lemma}
  
\begin{proof}
  Since the structure of the formulae and tableau rules are not involved
  in the proof from \citet*{bolander2009terminating} holds here as well.
  
  
  \iffalse
  The 'if' direction follows from the observation that the
  talbeau rules can only generate a finite tableau while not
  generating additional nominals, since our conventions
  ensure that all formulae occuring $\Theta$ are distinct.
  For the other direction, first we demonstrate
  $N_{\Theta}$ is infinite.  Suppose by contradiction
  $N_{\Theta}$ is finite
  \fi
\end{proof}


\begin{definition}[$\subseteq_{\Theta}$]
  Where $a$ and $b$ are nominals occuring on an {\it FHTL} tableau branch
  $\Theta$, $a$ is {\it included} in $b$ with respect to $\Theta$
  if for any root subformula $\phi$, if $@_a \phi$ occurs on $\Theta$
  then $@_b \phi$ also occurs on $\Theta$, similarly for their negations.
  If $a$  is included in $b$ with respect to $\Theta$,
  and the first occurence of $b$ on $\Theta$ is
  before the first occurence of $a$ on $\Theta$, then
  we write $a \subseteq_{\Theta} b$.
\end{definition}

\begin{definition}[$\sim_{\Theta}$]
  Where $\Theta$ is a {\it FHTL} tableau branch, 
  define a binary relation $\sim_{\Theta}$
  on $N_{\Theta}$ by $a \sim_{\Theta} b$ if and only if
  $@_a b$ occurs on $\Theta$.
  Let $\sim_{\Theta}^*$ be reflexive, transitive,
  and symmetric closure of $\sim_{\Theta}$.
\end{definition}

\begin{definition}[$W, \approx$]
  Let $W$ be the subset of
  $N_{\Theta}$ containing any nominal
  $a$ with the property that there
  is no nominal $b$ such that
  $a \subseteq_{\Theta} b$.
  Let $\approx$ be the restriction of $\sim_{\Theta}$ 
  to $W$.
\end{definition}

\begin{definition}
  Let $R$ be the binary relation defined on $W$
  defined by $a R c$ if and only if there are nominals
  $a' \approx a$ and $c' \approx c$ satisfying one of the
  following conditions:
  \begin{enumerate}
  \item

    The formula $@_{a'} F c'$ or $@_{a'} P c'$
    occurs at $\Theta$ and was introduced to the
    branch
    by $F$ or $P$ respectively.
  \item

    There is a nominal $d \in N_{\Theta}$
    such that the formula $@_{a'} F d$ or $@_{a'} P d$
    was introduced to the branch by
    $F$ or $P$ respectively 
    and $d \subseteq_{\Theta} c'$
  \item
    The formula $@_{a'} F c'$ or $@_{a'} P c'$
    occurs at $\Theta$ and $a'$ or $c'$
    occurs in the root formula.
  \end{enumerate}
\end{definition}

\iffalse
The proof of soundness and completeness of
{\it FHL} in \citet*{hansen2007tableau}
uses the notions of $\lozenge$--{\it completeness}
and $\exists$--{\it completeness}.  As a result we substitute
$\lozenge$--completeness with the equivalent notion 
$F$--{\it completeness} and add the notion of
$P$--{\it completeness} where the $\exists$--completeness
stays the same as before.  Thus set of $@$-formulae
(formulae in the extended language (including parameters) of the form $@_i \phi$)
is $F$--complete if:
$$@_i F \phi \in S \Longrightarrow @_i F j \text{ or } @_j P i, @_j \phi \in S, \text{ for some nominal } j$$
A set of $@$-formulae is $P$--complete if:
$$@_i P \phi \in S \Longrightarrow @_i P j \text{ or } @_j F i, @_j \phi \in S, \text{ for some nominal } j$$
Soundness and completeness for for {\it FHTL} follows straightforward modification of Hansen's proof of soundness and completeness
for {\it FHL} in a way that reflects the new formulae of the form $@_i P \phi$. 
\fi

\iffalse
\subsubsection{Adding unification}


  \begin{figure*}
  \centering
  \begin{mdframed}
    \underline{\bf Quantifier rules for tableau with unification:}
    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{$@_s \exists x \phi$}
        \RightLabel{\bf ($\exists$)\footnote{$f$ is a new Skolem function and $u_1 : y_1,..., u_n : y_n$ are the prefixed variables free in $\phi$}}
        \UnaryInfC{$@_s \phi[f(u_1 : y_1 ,..., u_n : y_n ) / x]$} 
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_s \neg \exists x \phi$}
        \RightLabel{\bf ($\neg \exists$)\footnote{$s : y$ is a first-order variable new to the tableau and free in $\exists x \phi$.}}
        \UnaryInfC{$@_s \neg \phi[s : y / x]$} 
      \end{prooftree}
    \end{multicols}
  \end{mdframed}
\end{figure*}
\fi




\subsection{Tableau Construction}


\begin{definition}[{\bf Closed and open}]
  If a tableau branch contains a formula
  $@_s \phi$ and its negation $@_s \neg \phi$
  we say the branch is {\it closed}.
  If every branch of the tableau is closed we
  say the tableau itself is closed.  If a
  tableau or branch is not closed we say it is {\it open}.
\end{definition}

A closed tableau is a proof of the unsatisfiability of the tableau's root formula, i.e.
there is no model or assignment of variables in which it holds.  The question of when a tableau
indicates satisfiability of the root formula leads us to our next definition.

\begin{definition}[{\bf Saturation}]
  A tableau branch is {\it saturated}
  if no more rules can be applied to the branch in a way that
  satisfies their constraints.
  If every branch of the tableau
  is saturated we say the tableau is saturated.
\end{definition}


\section{Model Checking via Tableaux}

For our task of AMR inference, we are not concered with the determining the general satisfiability or
validity of an AMR formula translated into {\it FHTL}, but
rather whether it holds in the smallest model consistent with
an established set of {\it FTHL} translations of AMR sentences.
This model will necessarily be finite, since across any finite
number of AMR sentences only a finite number of times and entities
can be referenced. 
In particular, we have a case of a local model-checking problem
where given formula $\phi$, a finite {\it FHTL} model structure $\mathfrak{M}$, a time $t$
in $\mathfrak{M}$, and a variable assignment $g$, we need to determine
whether $\mathfrak{M}, t \vDash_g \phi$ \citep{muller1999model}.
\par
Consequently our use of tableaux for {\it FHTL} formulae will provide
a decision procedure for their satisfiability within a finite model generated
by some set of AMR sentences, rather than their general validity or invalidity,
as is usually the case with tableaux methods.  We develop an approach to using
tableaux as a means of model checking for {\it FHTL}
based on the approach in \citet{bohn1998first}. 

\begin{figure*}[!h]
  \begin{adjustbox}{varwidth=\linewidth,scale=1.0}
    %% \begin{framed}
    \centering
    
    \begin{mdframed}
    \centering
    
    \underline{\bf Equality rules:}


    \begin{multicols}{2}
      \begin{prooftree}
        \AxiomC{[$i$ and $j$ on the branch.]}
        \RightLabel{\bf (ref)\footnote{\label{closed}$t$ is a closed term on the branch, $j$ not among its prefixes.}}
        \UnaryInfC{$@_i j:t = j:t$} 
      \end{prooftree}
      
      
      \begin{prooftree}
        \AxiomC{$@_i j:t = k:s$}
        \AxiomC{$@_i \phi$}
        \RightLabel{\bf (sub)\footnote{\label{subst}$\phi[j:t // k:s]$ is $\phi$ where some occurences of $j:t$ have been replaced by $k:s$.}}
        \BinaryInfC{$@_i \phi[j:t // k:s]$} 
      \end{prooftree}
    \end{multicols}
    
    
    \underline{\bf {\it FHTL} term rules:}
    
    \begin{multicols}{3}
      \begin{prooftree}
        \AxiomC{$@_i j_1 : t = j_2 : s$}
        \RightLabel{\bf (:1)\footnote{\label{k}$k$ on the branch.}}
        \UnaryInfC{$@_k j_1 : t = j_2 : s$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_i j$}
        \RightLabel{\bf (:2)\footnoteref{k}\footnote{\label{t}$t$ is a closed term on the branch, and $i$, $j$ are distinct nominals on the branch, not among the prefixes of $t$.}}
        \UnaryInfC{$@_k i: t = j : t$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{}
        \RightLabel{\bf (:3)\footnoteref{k}\footnoteref{t}}
        \UnaryInfC{$@_k j :i: t = i : t$}
      \end{prooftree}
    \end{multicols}

    \begin{multicols}{2}
    %%\begin{multicols}{4}
      \begin{prooftree}
        \AxiomC{$@_i R(t_1,...,t_n)$}
        \RightLabel{\bf (:fix 1)\footnote{\label{r} $i$ is not among the prefixes of the terms in the consequent.}}
        \UnaryInfC{$@_i R(i:t_1,...,i:t_n)$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_i \neg R(t_1,...,t_n)$}
        \RightLabel{\bf (:fix 2)\footnoteref{r}}
        \UnaryInfC{$@_i \neg R(i:t_1,...,i:t_n)$}
      \end{prooftree}
    \end{multicols}
    
    \begin{multicols}{2}  
      \begin{prooftree}
        \AxiomC{$@_i t = s$}
        \RightLabel{\bf (:fix 3)\footnoteref{r}}
        \UnaryInfC{$@_i i : t = i : s$}
      \end{prooftree}
      
      \begin{prooftree}
        \AxiomC{$@_i \neg t = s$}
        \RightLabel{\bf (:fix 4)\footnoteref{r}}
        \UnaryInfC{$@_i \neg i : t = i : s$}
      \end{prooftree}
    \end{multicols}
    
    \begin{prooftree}
      \AxiomC{[$i$ and one of the two function terms on the branch]}
      \RightLabel{\bf (:func)\footnote{$f$ is an $n$--ary function symbol and $t_1,...,t_n$ are closed terms with $i$ not among their prefixes.}}
      \UnaryInfC{$@_i f(t_1,..., t_n) = f(i:t_1,..., i:t_n)$}
    \end{prooftree}
    
  \end{mdframed}
\end{adjustbox}
\end{figure*}



\subsection{Systematic tableau construction}

\begin{definition}[{\it Tableau construction algorithm}]
  Where $@a_a \phi$ is the formula whose validity we are deciding.
  We inductively define a sequence of finite tableaux
  $\mathcal{T}_0, \mathcal{T}_1, \mathcal{T}_2, \ldots$
  each where each element of the sequence is embedded in all
  of its successors.  We let $\mathcal{T}_0$ be the finite
  tableau consisting of the formula $\neg @a_a \phi$.
  Assuming the finite tableau $\mathcal{T}_n$ is defined.
  If possible, apply an arbitrary {\it FHTL} tableau rule with
  the following restriction.
  \begin{itemize}
  \item {\bf (Loop check)}
    The rule $F$ is not applied to a formula occurence $@_a F \phi$
    at a branch $\Theta$ if there is a nominal $b$ such that
    $a \subseteq_{\Theta} b$, and simlarly for the rule $P$.
  \end{itemize}
  Let $\mathcal{T}_{n + 1}$ be the resulting tableau.
\end{definition}

\begin{theorem}
  The systematic tableau construction algorithm terminates.
\end{theorem}

\begin{proof}
  Suppose by contradiction the ned
\end{proof}



\subsection{Node Annotation}

The approach involves annotating each node of an open
branch with the variable assignments in the model which witness the
formula at the node, building inductively from the terminal nodes.
If the root formula of the tableau with at least one open branch
can be annotated with non-empty set of
variable assignments, then it is satisfiable in the model.
If a tableau is closed then the root formula $@_s \phi$ is unsatisfiable.
As a result if the root formula is of the form $@_s \neg \psi$
then this constitutes a proof of the validity of $@_s \psi$ by contradiction.
We now view each node in the tableau graph as a pair $( @_s \phi , \mathcal{V} )$, 
of the formula at the node and the set $\mathcal{V}$ of variable assignments
in our model $\mathfrak{M}$ which
witness the formula.  We define an annotation function $\textit{ann}(@_s \phi) = \mathcal{V}$  
beginning with terminal nodes:
$$\textit{ann}(@_s \phi) = \{g \mid \mathfrak{M}, I_{\textit{nom}} (s) \vDash_g \phi\}$$
\section{AMR Interpretation in {\it FHTL}}

\subsection{Examples}

\enumsentence{
  a. Carl filled out the forms and everyone will submit them tomorrow.
  \\
  b.
  \\
  \scriptsize\texttt{(a / and\\
    \hspace*{0.5cm}:op1 (s / scope\\
    \hspace*{1.0cm}:pred (f / fill-out-03 :ongoing - :complete + :time (b / before :op1 (n / now))\\
    \hspace*{1.5cm}:ARG0 (p / person\\
    \hspace*{2.0cm}:name (n2 / name\\
    \hspace*{2.5cm}:op "Carl"))\\
    \hspace*{1.5cm}:ARG1 (f2 / form))\\
    \hspace*{1.0cm}:ARG0 p\\
    \hspace*{1.0cm}:ARG1 f2)\\
    \hspace*{0.5cm}:op2 (s2 / scope\\
    \hspace*{1.0cm}:pred (m / submit-01  :ongoing - :complete + :time (a2 / after :op1 n)\\
    \hspace*{1.5cm}:ARG0 (p2 / person\\
    \hspace*{2.0cm}:mod (a3 / all))\\
    \hspace*{1.5cm}:ARG1 f2)\\
    \hspace*{1.0cm}:ARG0 f2\\
    \hspace*{1.0cm}:ARG1 p2))}
  \\
  c. Technically correct:
  \\
  $@_{\textit{now}} \exists x [\texttt{form}(x) \land P \texttt{fill-out-03}(\texttt{Carl}, x)] \land @_{\textit{now}} \exists x [\texttt{form}(x) \land \forall y [\texttt{person}(y) \to F \texttt{submit-01}(y, x)]]$
  \\
  d. Correct wrt plurality:
  \\
  $@_{\textit{now}} \forall x [\texttt{form}(x) \land P \texttt{fill-out-03}(\texttt{Carl}, x)] \land @_{\textit{now}} \forall x [\texttt{form}(x) \land \forall y [\texttt{person}(y) \to F \texttt{submit-01}(y, x)]]$
  \\
  e. Correct wrt reentrance (but not plurality) (maybe requires the passive for singular case?):
  \\
  $@_{\textit{now}} \exists x [\texttt{form}(x) \land P \texttt{fill-out-03}(\texttt{Carl}, x) \land  \forall y [\texttt{person}(y) \to F \texttt{submit-01}(y, x)]]$
  \\
}
\enumsentence{
a. It was impossible not to notice the car.
\\
b.
\\
\small\texttt{(s / scope\\
  \hspace*{1.0cm}:pred (p / possible-01\\
  \hspace*{1.5cm}:ARG0 (n / notice-01  :ongoing - :complete + :time (b / before :op1 (n2 / now))\\
  \hspace*{2.0cm}:polarity (n3 / not)\\
  \hspace*{2.0cm}:ARG1 (c / car)\\
  \hspace*{1.5cm}:polarity (n4 / not))\\
  \hspace*{1.0cm}:ARG0 n4\\
  \hspace*{1.0cm}:ARG1 p))}
\\
c. Incorrect:
\\
$@_{\textit{now}} \neg F \exists x [\texttt{car}(x) \land \neg P \texttt{notice-01}(x)]$
\\
d. Technically correct:
\\
$@_{\textit{now}} \neg F \exists x [\texttt{car}(x) \land \neg \forall y [ \texttt{person}(y) \to P \texttt{notice-01}(x, y)]]$
\\
e. Correct wrt particularity of the car:
\\
$@_{\textit{now}} \neg F \neg \forall x [ \texttt{person}(y) \to P \texttt{notice-01}(\texttt{car}, y)]]$
\\
}
\smallskip
NB: Will complete these translations in full.
\subsection{Extraction Steps}
With the chosen annotation, the root node
can consist of either a logical connective
(\verb|and|, \verb|or|, or \verb|cond|) linking two
AMR graphs, or a \verb|scope| node with its following
predicate and arguments.      

\subsection{General Extraction Algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \SetKwInput{KwInput}{Input}                % Set the Input
  \SetKwInput{KwOutput}{Output}              % set the Output
  \DontPrintSemicolon

  \KwInput{AMR sentence}
  \KwOutput{{\it FHTL} formula}

  % Set Function Names
  \SetKwFunction{FApply}{Apply}
  \SetKwFunction{FInterpretEntry}{InterpretEntry}
  \SetKwFunction{FInterpretClause}{InterpretClause}
  \SetKwFunction{FInterpretPred}{InterpretPred}
  \SetKwFunction{FInferArg}{InferArg}
  \SetKwFunction{FRemoveSubgraph}{RemoveSubgraph}
  \SetKwFunction{FTime}{Time}
  \SetKwFunction{FTense}{Tense}
  \SetKwFunction{FPred}{Pred}
  \SetKwFunction{FReference}{Reference}
  \SetKwFunction{FGetArgs}{GetArgs}
  
  \SetKwProg{Fn}{Def}{:}{}
  \Fn{\FInterpretEntry{AMR}}{
    root = Root(AMR)\;
    now = current date/time\;
    \If{root $\in \{ \texttt{and},\texttt{or}, \texttt{cond} \}$}{
      connective = filter(root, $\{ \land, \lor, \to \}$)\;
      clauses = []\;
      \For{\texttt{op} $\in$ Children(root)}{
        append(clauses, \FInterpretClause(\texttt{op}))\;
      }
      \Return $@_{\text{now}}$ join(connective, clauses)\;
    }
    \Return $@_{\text{now}}$ \FInterpretClause(root)\;
  }
  \;

  \Fn{\FInterpretClause{AMR}}{
    time = \FTime(AMR)\;
    nominal = \FReference(time)\;
    tense = \FTense(time)\;
    %% pred = \FInferArg( \FPred(AMR))(tense)\;
    pred = \FPred(AMR)(tense)\;
    $\text{Arg}_0$, $\text{Arg}_1$ = \FGetArgs(AMR)\; 
    \Return $@_{\text{nominal}}$ \FApply($\text{Arg}_0$, \FApply($\text{Arg}_0$, pred))\;
  }
  \;
  
 \caption{Basic transformation into {\it FHTL} clauses and connectives.}
\end{algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \SetKwInput{KwInput}{Input}                % Set the Input
  \SetKwInput{KwOutput}{Output}              % set the Output
  \DontPrintSemicolon

  \KwInput{AMR sentence}
  \KwOutput{{\it FHTL} formula}  
  \SetKwFunction{FApply}{Apply}
  \SetKwFunction{FInterpretPred}{InterpretPred}

  
  \SetKwProg{Fn}{Def}{:}{}
  
  \Fn{\FApply{$\text{pred}_1$,$\text{pred}_2$}}{
    \Return $\lambda \phi . \text{pred}_1 (\lambda \psi . \text{pred}_2 (\lambda \gamma . \phi (\psi (\gamma))))$
  }
  \;
  
  \Fn{\FInterpretPred{UnaryPred}}{
    \If{hasMods(UnaryPred)}{
      mods = [name(UnaryPred)]\;
      \For{mod $\in$ Children(UnaryPred)}{
        append(mods, name(mod)($x$))\;
      }
      FinalPred = $\lambda x .$ join(mods, $\land$)\;
    } \Else{
      FinalPred = $\lambda  x . \text{name(UnaryPred)}(x)$\; 
    }
    \If{Quant(UnaryPred) == :all}{
      \Return $\lambda k . \forall x [ \text{FinalPred} (x) \to k (x) ]$\; 
    } \Else{
      \Return $\lambda k . \exists x [ \text{FinalPred} (x) \land k (x) ]$\;
    }
  }
  \;

  \caption{Supporting definitions.}
\end{algorithm}


\section{Future Work}

\subsection{$\downarrow$ and Quantification over Nominals}
Main points, at the cost of undecidability with adding $\downarrow$
some additional things can be done,
and at the cost of the integration of generalized quantifiers you can
ostensibly handle even things like habitual aspect.

\subsection{AMR Reentrancy and Non-Temoral Nominals}


There are some difficulties with maintaining the usual notion of possible
worlds being maximal with this idea, but there seems to be a direct sympathy between
the predicative core of an AMR sentence and in general reentrancy of the nodes with the
idea of a nominal as a ``point of view'' rather than the ``name'' of a world.
Maybe things like epistemic logic could be helpful here.
\subsection{Automated Inference and HTab}

HTab \citep{htab} provides an implementation of $\mathcal{H}(@, \textsf{A})$,
which does not natively provide a way to reason with $P$, $H$,
or first-order quantification.  The effort required in making the needed
changes to handle these remains to be determined.
\subsection{The Future of AMR and Parsing for Semantic Features}

To what extent can current AMR parsers extract the needed semantic features
to make full use of automated inference?  Of UMR, Dialogue-AMR,
and the AMR annotation variants we've used,
which logistically has the best outlook?


\section{Conclusion}

We have demonstrated how the core aspects of AMR along with annotations
for scope, quantification, and tense, can be accomodated
in first-order hybrid tense logic, and that {\it FHTL}
better affords reasoning and inference than AMR,
given its general tableau method which acts as a proof procedure for {\it FHTL} sentences
and its terminating tableau methond which acts as a model checker.  

\bibliographystyle{acl_natbib}
\bibliography{references}
\end{document}
